package com.abiquo.aimstub.finagle;


/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

import com.twitter.util.Future;
import com.twitter.util.Function;
import com.twitter.util.Function2;
import com.twitter.util.Try;
import com.twitter.util.Return;
import com.twitter.util.Throw;
import com.twitter.finagle.thrift.ThriftClientRequest;

public class Aim {

  public interface Iface {

    public void checkRimpConfiguration() throws RimpException, TException;

    public long getDatastoreSize() throws RimpException, TException;

    public long getDiskFileSize(String virtualImageDatastorePath) throws RimpException, TException;

    public List<Datastore> getDatastores() throws RimpException, TException;

    public List<NetInterface> getNetInterfaces() throws RimpException, TException;

    public void copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID) throws RimpException, TException;

    public void deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID) throws RimpException, TException;

    public void copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath) throws RimpException, TException;

    public void createVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws VLanException, TException;

    public void deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws VLanException, TException;

    public void checkVLANConfiguration() throws VLanException, TException;

    public String getInitiatorIQN() throws TException;

  }

  public interface AsyncIface {

    public void checkRimpConfiguration(AsyncMethodCallback<AsyncClient.checkRimpConfiguration_call> resultHandler) throws TException;

    public void getDatastoreSize(AsyncMethodCallback<AsyncClient.getDatastoreSize_call> resultHandler) throws TException;

    public void getDiskFileSize(String virtualImageDatastorePath, AsyncMethodCallback<AsyncClient.getDiskFileSize_call> resultHandler) throws TException;

    public void getDatastores(AsyncMethodCallback<AsyncClient.getDatastores_call> resultHandler) throws TException;

    public void getNetInterfaces(AsyncMethodCallback<AsyncClient.getNetInterfaces_call> resultHandler) throws TException;

    public void copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID, AsyncMethodCallback<AsyncClient.copyFromRepositoryToDatastore_call> resultHandler) throws TException;

    public void deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID, AsyncMethodCallback<AsyncClient.deleteVirtualImageFromDatastore_call> resultHandler) throws TException;

    public void copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath, AsyncMethodCallback<AsyncClient.copyFromDatastoreToRepository_call> resultHandler) throws TException;

    public void createVLAN(int vlanTag, String vlanInterface, String bridgeInterface, AsyncMethodCallback<AsyncClient.createVLAN_call> resultHandler) throws TException;

    public void deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface, AsyncMethodCallback<AsyncClient.deleteVLAN_call> resultHandler) throws TException;

    public void checkVLANConfiguration(AsyncMethodCallback<AsyncClient.checkVLANConfiguration_call> resultHandler) throws TException;

    public void getInitiatorIQN(AsyncMethodCallback<AsyncClient.getInitiatorIQN_call> resultHandler) throws TException;

  }

  public interface ServiceIface {

    public Future<Void> checkRimpConfiguration();

    public Future<Long> getDatastoreSize();

    public Future<Long> getDiskFileSize(String virtualImageDatastorePath);

    public Future<List<Datastore>> getDatastores();

    public Future<List<NetInterface>> getNetInterfaces();

    public Future<Void> copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID);

    public Future<Void> deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID);

    public Future<Void> copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath);

    public Future<Void> createVLAN(int vlanTag, String vlanInterface, String bridgeInterface);

    public Future<Void> deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface);

    public Future<Void> checkVLANConfiguration();

    public Future<String> getInitiatorIQN();

  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void checkRimpConfiguration() throws RimpException, TException
    {
      send_checkRimpConfiguration();
      recv_checkRimpConfiguration();
    }

    public void send_checkRimpConfiguration() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.CALL, ++seqid_));
      checkRimpConfiguration_args args = new checkRimpConfiguration_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_checkRimpConfiguration() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "checkRimpConfiguration failed: out of sequence response");
      }
      checkRimpConfiguration_result result = new checkRimpConfiguration_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.re != null) {
        throw result.re;
      }
      return;
    }

    public long getDatastoreSize() throws RimpException, TException
    {
      send_getDatastoreSize();
      return recv_getDatastoreSize();
    }

    public void send_getDatastoreSize() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.CALL, ++seqid_));
      getDatastoreSize_args args = new getDatastoreSize_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_getDatastoreSize() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getDatastoreSize failed: out of sequence response");
      }
      getDatastoreSize_result result = new getDatastoreSize_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.re != null) {
        throw result.re;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDatastoreSize failed: unknown result");
    }

    public long getDiskFileSize(String virtualImageDatastorePath) throws RimpException, TException
    {
      send_getDiskFileSize(virtualImageDatastorePath);
      return recv_getDiskFileSize();
    }

    public void send_getDiskFileSize(String virtualImageDatastorePath) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.CALL, ++seqid_));
      getDiskFileSize_args args = new getDiskFileSize_args();
      args.setVirtualImageDatastorePath(virtualImageDatastorePath);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public long recv_getDiskFileSize() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getDiskFileSize failed: out of sequence response");
      }
      getDiskFileSize_result result = new getDiskFileSize_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.re != null) {
        throw result.re;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDiskFileSize failed: unknown result");
    }

    public List<Datastore> getDatastores() throws RimpException, TException
    {
      send_getDatastores();
      return recv_getDatastores();
    }

    public void send_getDatastores() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDatastores", TMessageType.CALL, ++seqid_));
      getDatastores_args args = new getDatastores_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Datastore> recv_getDatastores() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getDatastores failed: out of sequence response");
      }
      getDatastores_result result = new getDatastores_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.re != null) {
        throw result.re;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDatastores failed: unknown result");
    }

    public List<NetInterface> getNetInterfaces() throws RimpException, TException
    {
      send_getNetInterfaces();
      return recv_getNetInterfaces();
    }

    public void send_getNetInterfaces() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.CALL, ++seqid_));
      getNetInterfaces_args args = new getNetInterfaces_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<NetInterface> recv_getNetInterfaces() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getNetInterfaces failed: out of sequence response");
      }
      getNetInterfaces_result result = new getNetInterfaces_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.re != null) {
        throw result.re;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getNetInterfaces failed: unknown result");
    }

    public void copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID) throws RimpException, TException
    {
      send_copyFromRepositoryToDatastore(virtualImageRepositoryPath, datastorePath, virtualMachineUUID);
      recv_copyFromRepositoryToDatastore();
    }

    public void send_copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.CALL, ++seqid_));
      copyFromRepositoryToDatastore_args args = new copyFromRepositoryToDatastore_args();
      args.setVirtualImageRepositoryPath(virtualImageRepositoryPath);
      args.setDatastorePath(datastorePath);
      args.setVirtualMachineUUID(virtualMachineUUID);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_copyFromRepositoryToDatastore() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "copyFromRepositoryToDatastore failed: out of sequence response");
      }
      copyFromRepositoryToDatastore_result result = new copyFromRepositoryToDatastore_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.re != null) {
        throw result.re;
      }
      return;
    }

    public void deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID) throws RimpException, TException
    {
      send_deleteVirtualImageFromDatastore(datastorePath, virtualMachineUUID);
      recv_deleteVirtualImageFromDatastore();
    }

    public void send_deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.CALL, ++seqid_));
      deleteVirtualImageFromDatastore_args args = new deleteVirtualImageFromDatastore_args();
      args.setDatastorePath(datastorePath);
      args.setVirtualMachineUUID(virtualMachineUUID);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteVirtualImageFromDatastore() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteVirtualImageFromDatastore failed: out of sequence response");
      }
      deleteVirtualImageFromDatastore_result result = new deleteVirtualImageFromDatastore_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.re != null) {
        throw result.re;
      }
      return;
    }

    public void copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath) throws RimpException, TException
    {
      send_copyFromDatastoreToRepository(virtualMachineUUID, snapshot, destinationRepositoryPath, sourceDatastorePath);
      recv_copyFromDatastoreToRepository();
    }

    public void send_copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.CALL, ++seqid_));
      copyFromDatastoreToRepository_args args = new copyFromDatastoreToRepository_args();
      args.setVirtualMachineUUID(virtualMachineUUID);
      args.setSnapshot(snapshot);
      args.setDestinationRepositoryPath(destinationRepositoryPath);
      args.setSourceDatastorePath(sourceDatastorePath);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_copyFromDatastoreToRepository() throws RimpException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "copyFromDatastoreToRepository failed: out of sequence response");
      }
      copyFromDatastoreToRepository_result result = new copyFromDatastoreToRepository_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.re != null) {
        throw result.re;
      }
      return;
    }

    public void createVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws VLanException, TException
    {
      send_createVLAN(vlanTag, vlanInterface, bridgeInterface);
      recv_createVLAN();
    }

    public void send_createVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("createVLAN", TMessageType.CALL, ++seqid_));
      createVLAN_args args = new createVLAN_args();
      args.setVlanTag(vlanTag);
      args.setVlanInterface(vlanInterface);
      args.setBridgeInterface(bridgeInterface);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_createVLAN() throws VLanException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "createVLAN failed: out of sequence response");
      }
      createVLAN_result result = new createVLAN_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ve != null) {
        throw result.ve;
      }
      return;
    }

    public void deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws VLanException, TException
    {
      send_deleteVLAN(vlanTag, vlanInterface, bridgeInterface);
      recv_deleteVLAN();
    }

    public void send_deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.CALL, ++seqid_));
      deleteVLAN_args args = new deleteVLAN_args();
      args.setVlanTag(vlanTag);
      args.setVlanInterface(vlanInterface);
      args.setBridgeInterface(bridgeInterface);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_deleteVLAN() throws VLanException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "deleteVLAN failed: out of sequence response");
      }
      deleteVLAN_result result = new deleteVLAN_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ve != null) {
        throw result.ve;
      }
      return;
    }

    public void checkVLANConfiguration() throws VLanException, TException
    {
      send_checkVLANConfiguration();
      recv_checkVLANConfiguration();
    }

    public void send_checkVLANConfiguration() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.CALL, ++seqid_));
      checkVLANConfiguration_args args = new checkVLANConfiguration_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_checkVLANConfiguration() throws VLanException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "checkVLANConfiguration failed: out of sequence response");
      }
      checkVLANConfiguration_result result = new checkVLANConfiguration_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.ve != null) {
        throw result.ve;
      }
      return;
    }

    public String getInitiatorIQN() throws TException
    {
      send_getInitiatorIQN();
      return recv_getInitiatorIQN();
    }

    public void send_getInitiatorIQN() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.CALL, ++seqid_));
      getInitiatorIQN_args args = new getInitiatorIQN_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_getInitiatorIQN() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getInitiatorIQN failed: out of sequence response");
      }
      getInitiatorIQN_result result = new getInitiatorIQN_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getInitiatorIQN failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void checkRimpConfiguration(AsyncMethodCallback<checkRimpConfiguration_call> resultHandler) throws TException {
      checkReady();
      checkRimpConfiguration_call method_call = new checkRimpConfiguration_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class checkRimpConfiguration_call extends TAsyncMethodCall {
      public checkRimpConfiguration_call(AsyncMethodCallback<checkRimpConfiguration_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.CALL, 0));
        checkRimpConfiguration_args args = new checkRimpConfiguration_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RimpException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_checkRimpConfiguration();
      }
    }

    public void getDatastoreSize(AsyncMethodCallback<getDatastoreSize_call> resultHandler) throws TException {
      checkReady();
      getDatastoreSize_call method_call = new getDatastoreSize_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getDatastoreSize_call extends TAsyncMethodCall {
      public getDatastoreSize_call(AsyncMethodCallback<getDatastoreSize_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.CALL, 0));
        getDatastoreSize_args args = new getDatastoreSize_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws RimpException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getDatastoreSize();
      }
    }

    public void getDiskFileSize(String virtualImageDatastorePath, AsyncMethodCallback<getDiskFileSize_call> resultHandler) throws TException {
      checkReady();
      getDiskFileSize_call method_call = new getDiskFileSize_call(virtualImageDatastorePath, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getDiskFileSize_call extends TAsyncMethodCall {
      private String virtualImageDatastorePath;
      public getDiskFileSize_call(String virtualImageDatastorePath, AsyncMethodCallback<getDiskFileSize_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.virtualImageDatastorePath = virtualImageDatastorePath;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.CALL, 0));
        getDiskFileSize_args args = new getDiskFileSize_args();
        args.setVirtualImageDatastorePath(virtualImageDatastorePath);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public long getResult() throws RimpException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getDiskFileSize();
      }
    }

    public void getDatastores(AsyncMethodCallback<getDatastores_call> resultHandler) throws TException {
      checkReady();
      getDatastores_call method_call = new getDatastores_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getDatastores_call extends TAsyncMethodCall {
      public getDatastores_call(AsyncMethodCallback<getDatastores_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getDatastores", TMessageType.CALL, 0));
        getDatastores_args args = new getDatastores_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Datastore> getResult() throws RimpException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getDatastores();
      }
    }

    public void getNetInterfaces(AsyncMethodCallback<getNetInterfaces_call> resultHandler) throws TException {
      checkReady();
      getNetInterfaces_call method_call = new getNetInterfaces_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getNetInterfaces_call extends TAsyncMethodCall {
      public getNetInterfaces_call(AsyncMethodCallback<getNetInterfaces_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.CALL, 0));
        getNetInterfaces_args args = new getNetInterfaces_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<NetInterface> getResult() throws RimpException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getNetInterfaces();
      }
    }

    public void copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID, AsyncMethodCallback<copyFromRepositoryToDatastore_call> resultHandler) throws TException {
      checkReady();
      copyFromRepositoryToDatastore_call method_call = new copyFromRepositoryToDatastore_call(virtualImageRepositoryPath, datastorePath, virtualMachineUUID, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class copyFromRepositoryToDatastore_call extends TAsyncMethodCall {
      private String virtualImageRepositoryPath;
      private String datastorePath;
      private String virtualMachineUUID;
      public copyFromRepositoryToDatastore_call(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID, AsyncMethodCallback<copyFromRepositoryToDatastore_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.virtualImageRepositoryPath = virtualImageRepositoryPath;
        this.datastorePath = datastorePath;
        this.virtualMachineUUID = virtualMachineUUID;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.CALL, 0));
        copyFromRepositoryToDatastore_args args = new copyFromRepositoryToDatastore_args();
        args.setVirtualImageRepositoryPath(virtualImageRepositoryPath);
        args.setDatastorePath(datastorePath);
        args.setVirtualMachineUUID(virtualMachineUUID);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RimpException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_copyFromRepositoryToDatastore();
      }
    }

    public void deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID, AsyncMethodCallback<deleteVirtualImageFromDatastore_call> resultHandler) throws TException {
      checkReady();
      deleteVirtualImageFromDatastore_call method_call = new deleteVirtualImageFromDatastore_call(datastorePath, virtualMachineUUID, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteVirtualImageFromDatastore_call extends TAsyncMethodCall {
      private String datastorePath;
      private String virtualMachineUUID;
      public deleteVirtualImageFromDatastore_call(String datastorePath, String virtualMachineUUID, AsyncMethodCallback<deleteVirtualImageFromDatastore_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.datastorePath = datastorePath;
        this.virtualMachineUUID = virtualMachineUUID;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.CALL, 0));
        deleteVirtualImageFromDatastore_args args = new deleteVirtualImageFromDatastore_args();
        args.setDatastorePath(datastorePath);
        args.setVirtualMachineUUID(virtualMachineUUID);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RimpException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteVirtualImageFromDatastore();
      }
    }

    public void copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath, AsyncMethodCallback<copyFromDatastoreToRepository_call> resultHandler) throws TException {
      checkReady();
      copyFromDatastoreToRepository_call method_call = new copyFromDatastoreToRepository_call(virtualMachineUUID, snapshot, destinationRepositoryPath, sourceDatastorePath, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class copyFromDatastoreToRepository_call extends TAsyncMethodCall {
      private String virtualMachineUUID;
      private String snapshot;
      private String destinationRepositoryPath;
      private String sourceDatastorePath;
      public copyFromDatastoreToRepository_call(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath, AsyncMethodCallback<copyFromDatastoreToRepository_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.virtualMachineUUID = virtualMachineUUID;
        this.snapshot = snapshot;
        this.destinationRepositoryPath = destinationRepositoryPath;
        this.sourceDatastorePath = sourceDatastorePath;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.CALL, 0));
        copyFromDatastoreToRepository_args args = new copyFromDatastoreToRepository_args();
        args.setVirtualMachineUUID(virtualMachineUUID);
        args.setSnapshot(snapshot);
        args.setDestinationRepositoryPath(destinationRepositoryPath);
        args.setSourceDatastorePath(sourceDatastorePath);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws RimpException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_copyFromDatastoreToRepository();
      }
    }

    public void createVLAN(int vlanTag, String vlanInterface, String bridgeInterface, AsyncMethodCallback<createVLAN_call> resultHandler) throws TException {
      checkReady();
      createVLAN_call method_call = new createVLAN_call(vlanTag, vlanInterface, bridgeInterface, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class createVLAN_call extends TAsyncMethodCall {
      private int vlanTag;
      private String vlanInterface;
      private String bridgeInterface;
      public createVLAN_call(int vlanTag, String vlanInterface, String bridgeInterface, AsyncMethodCallback<createVLAN_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.vlanTag = vlanTag;
        this.vlanInterface = vlanInterface;
        this.bridgeInterface = bridgeInterface;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("createVLAN", TMessageType.CALL, 0));
        createVLAN_args args = new createVLAN_args();
        args.setVlanTag(vlanTag);
        args.setVlanInterface(vlanInterface);
        args.setBridgeInterface(bridgeInterface);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws VLanException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_createVLAN();
      }
    }

    public void deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface, AsyncMethodCallback<deleteVLAN_call> resultHandler) throws TException {
      checkReady();
      deleteVLAN_call method_call = new deleteVLAN_call(vlanTag, vlanInterface, bridgeInterface, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class deleteVLAN_call extends TAsyncMethodCall {
      private int vlanTag;
      private String vlanInterface;
      private String bridgeInterface;
      public deleteVLAN_call(int vlanTag, String vlanInterface, String bridgeInterface, AsyncMethodCallback<deleteVLAN_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.vlanTag = vlanTag;
        this.vlanInterface = vlanInterface;
        this.bridgeInterface = bridgeInterface;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.CALL, 0));
        deleteVLAN_args args = new deleteVLAN_args();
        args.setVlanTag(vlanTag);
        args.setVlanInterface(vlanInterface);
        args.setBridgeInterface(bridgeInterface);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws VLanException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_deleteVLAN();
      }
    }

    public void checkVLANConfiguration(AsyncMethodCallback<checkVLANConfiguration_call> resultHandler) throws TException {
      checkReady();
      checkVLANConfiguration_call method_call = new checkVLANConfiguration_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class checkVLANConfiguration_call extends TAsyncMethodCall {
      public checkVLANConfiguration_call(AsyncMethodCallback<checkVLANConfiguration_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.CALL, 0));
        checkVLANConfiguration_args args = new checkVLANConfiguration_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws VLanException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_checkVLANConfiguration();
      }
    }

    public void getInitiatorIQN(AsyncMethodCallback<getInitiatorIQN_call> resultHandler) throws TException {
      checkReady();
      getInitiatorIQN_call method_call = new getInitiatorIQN_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getInitiatorIQN_call extends TAsyncMethodCall {
      public getInitiatorIQN_call(AsyncMethodCallback<getInitiatorIQN_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.CALL, 0));
        getInitiatorIQN_args args = new getInitiatorIQN_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public String getResult() throws TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getInitiatorIQN();
      }
    }

  }

  public static class ServiceToClient implements ServiceIface {
    private com.twitter.finagle.Service<ThriftClientRequest, byte[]> service;
    private TProtocolFactory protocolFactory;
    public ServiceToClient(com.twitter.finagle.Service<ThriftClientRequest, byte[]> service, TProtocolFactory protocolFactory) {
      this.service = service;
      this.protocolFactory = protocolFactory;
    }

    public Future<Void> checkRimpConfiguration() {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.CALL, 0));
        checkRimpConfiguration_args __args__ = new checkRimpConfiguration_args();
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Void>>() {
          public Future<Void> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              (new Client(__prot__)).recv_checkRimpConfiguration();
              return Future.value(null);
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Long> getDatastoreSize() {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.CALL, 0));
        getDatastoreSize_args __args__ = new getDatastoreSize_args();
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Long>>() {
          public Future<Long> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_getDatastoreSize());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Long> getDiskFileSize(String virtualImageDatastorePath) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.CALL, 0));
        getDiskFileSize_args __args__ = new getDiskFileSize_args();
        __args__.setVirtualImageDatastorePath(virtualImageDatastorePath);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Long>>() {
          public Future<Long> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_getDiskFileSize());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<List<Datastore>> getDatastores() {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("getDatastores", TMessageType.CALL, 0));
        getDatastores_args __args__ = new getDatastores_args();
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<List<Datastore>>>() {
          public Future<List<Datastore>> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_getDatastores());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<List<NetInterface>> getNetInterfaces() {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.CALL, 0));
        getNetInterfaces_args __args__ = new getNetInterfaces_args();
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<List<NetInterface>>>() {
          public Future<List<NetInterface>> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_getNetInterfaces());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Void> copyFromRepositoryToDatastore(String virtualImageRepositoryPath, String datastorePath, String virtualMachineUUID) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.CALL, 0));
        copyFromRepositoryToDatastore_args __args__ = new copyFromRepositoryToDatastore_args();
        __args__.setVirtualImageRepositoryPath(virtualImageRepositoryPath);
        __args__.setDatastorePath(datastorePath);
        __args__.setVirtualMachineUUID(virtualMachineUUID);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Void>>() {
          public Future<Void> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              (new Client(__prot__)).recv_copyFromRepositoryToDatastore();
              return Future.value(null);
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Void> deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.CALL, 0));
        deleteVirtualImageFromDatastore_args __args__ = new deleteVirtualImageFromDatastore_args();
        __args__.setDatastorePath(datastorePath);
        __args__.setVirtualMachineUUID(virtualMachineUUID);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Void>>() {
          public Future<Void> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              (new Client(__prot__)).recv_deleteVirtualImageFromDatastore();
              return Future.value(null);
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Void> copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot, String destinationRepositoryPath, String sourceDatastorePath) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.CALL, 0));
        copyFromDatastoreToRepository_args __args__ = new copyFromDatastoreToRepository_args();
        __args__.setVirtualMachineUUID(virtualMachineUUID);
        __args__.setSnapshot(snapshot);
        __args__.setDestinationRepositoryPath(destinationRepositoryPath);
        __args__.setSourceDatastorePath(sourceDatastorePath);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Void>>() {
          public Future<Void> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              (new Client(__prot__)).recv_copyFromDatastoreToRepository();
              return Future.value(null);
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Void> createVLAN(int vlanTag, String vlanInterface, String bridgeInterface) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("createVLAN", TMessageType.CALL, 0));
        createVLAN_args __args__ = new createVLAN_args();
        __args__.setVlanTag(vlanTag);
        __args__.setVlanInterface(vlanInterface);
        __args__.setBridgeInterface(bridgeInterface);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Void>>() {
          public Future<Void> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              (new Client(__prot__)).recv_createVLAN();
              return Future.value(null);
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Void> deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface) {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.CALL, 0));
        deleteVLAN_args __args__ = new deleteVLAN_args();
        __args__.setVlanTag(vlanTag);
        __args__.setVlanInterface(vlanInterface);
        __args__.setBridgeInterface(bridgeInterface);
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Void>>() {
          public Future<Void> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              (new Client(__prot__)).recv_deleteVLAN();
              return Future.value(null);
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<Void> checkVLANConfiguration() {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.CALL, 0));
        checkVLANConfiguration_args __args__ = new checkVLANConfiguration_args();
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<Void>>() {
          public Future<Void> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              (new Client(__prot__)).recv_checkVLANConfiguration();
              return Future.value(null);
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
    public Future<String> getInitiatorIQN() {
      try {
        // TODO: size
        TMemoryBuffer __memoryTransport__ = new TMemoryBuffer(512);
        TProtocol __prot__ = this.protocolFactory.getProtocol(__memoryTransport__);
        __prot__.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.CALL, 0));
        getInitiatorIQN_args __args__ = new getInitiatorIQN_args();
        __args__.write(__prot__);
        __prot__.writeMessageEnd();
      

        byte[] __buffer__ = Arrays.copyOfRange(__memoryTransport__.getArray(), 0, __memoryTransport__.length());
        ThriftClientRequest __request__ = new ThriftClientRequest(__buffer__, false);
        Future<byte[]> __done__ = this.service.apply(__request__);
        return __done__.flatMap(new Function<byte[], Future<String>>() {
          public Future<String> apply(byte[] __buffer__) {
            TMemoryInputTransport __memoryTransport__ = new TMemoryInputTransport(__buffer__);
            TProtocol __prot__ = ServiceToClient.this.protocolFactory.getProtocol(__memoryTransport__);
            try {
              return Future.value((new Client(__prot__)).recv_getInitiatorIQN());
            } catch (Exception e) {
              return Future.exception(e);
            }
          }
        });
      } catch (TException e) {
        return Future.exception(e);
      }
    }
  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("checkRimpConfiguration", new checkRimpConfiguration());
      processMap_.put("getDatastoreSize", new getDatastoreSize());
      processMap_.put("getDiskFileSize", new getDiskFileSize());
      processMap_.put("getDatastores", new getDatastores());
      processMap_.put("getNetInterfaces", new getNetInterfaces());
      processMap_.put("copyFromRepositoryToDatastore", new copyFromRepositoryToDatastore());
      processMap_.put("deleteVirtualImageFromDatastore", new deleteVirtualImageFromDatastore());
      processMap_.put("copyFromDatastoreToRepository", new copyFromDatastoreToRepository());
      processMap_.put("createVLAN", new createVLAN());
      processMap_.put("deleteVLAN", new deleteVLAN());
      processMap_.put("checkVLANConfiguration", new checkVLANConfiguration());
      processMap_.put("getInitiatorIQN", new getInitiatorIQN());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class checkRimpConfiguration implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkRimpConfiguration_args args = new checkRimpConfiguration_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        checkRimpConfiguration_result result = new checkRimpConfiguration_result();
        try {
          iface_.checkRimpConfiguration();
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing checkRimpConfiguration", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing checkRimpConfiguration");
          oprot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDatastoreSize implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDatastoreSize_args args = new getDatastoreSize_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getDatastoreSize_result result = new getDatastoreSize_result();
        try {
          result.success = iface_.getDatastoreSize();
          result.setSuccessIsSet(true);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getDatastoreSize", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getDatastoreSize");
          oprot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDiskFileSize implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDiskFileSize_args args = new getDiskFileSize_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getDiskFileSize_result result = new getDiskFileSize_result();
        try {
          result.success = iface_.getDiskFileSize(args.virtualImageDatastorePath);
          result.setSuccessIsSet(true);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getDiskFileSize", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getDiskFileSize");
          oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDatastores implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDatastores_args args = new getDatastores_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getDatastores_result result = new getDatastores_result();
        try {
          result.success = iface_.getDatastores();
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getDatastores", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getDatastores");
          oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getNetInterfaces implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getNetInterfaces_args args = new getNetInterfaces_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getNetInterfaces_result result = new getNetInterfaces_result();
        try {
          result.success = iface_.getNetInterfaces();
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getNetInterfaces", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getNetInterfaces");
          oprot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class copyFromRepositoryToDatastore implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        copyFromRepositoryToDatastore_args args = new copyFromRepositoryToDatastore_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        copyFromRepositoryToDatastore_result result = new copyFromRepositoryToDatastore_result();
        try {
          iface_.copyFromRepositoryToDatastore(args.virtualImageRepositoryPath, args.datastorePath, args.virtualMachineUUID);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing copyFromRepositoryToDatastore", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing copyFromRepositoryToDatastore");
          oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteVirtualImageFromDatastore implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteVirtualImageFromDatastore_args args = new deleteVirtualImageFromDatastore_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteVirtualImageFromDatastore_result result = new deleteVirtualImageFromDatastore_result();
        try {
          iface_.deleteVirtualImageFromDatastore(args.datastorePath, args.virtualMachineUUID);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteVirtualImageFromDatastore", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteVirtualImageFromDatastore");
          oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class copyFromDatastoreToRepository implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        copyFromDatastoreToRepository_args args = new copyFromDatastoreToRepository_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        copyFromDatastoreToRepository_result result = new copyFromDatastoreToRepository_result();
        try {
          iface_.copyFromDatastoreToRepository(args.virtualMachineUUID, args.snapshot, args.destinationRepositoryPath, args.sourceDatastorePath);
        } catch (RimpException re) {
          result.re = re;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing copyFromDatastoreToRepository", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing copyFromDatastoreToRepository");
          oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class createVLAN implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        createVLAN_args args = new createVLAN_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        createVLAN_result result = new createVLAN_result();
        try {
          iface_.createVLAN(args.vlanTag, args.vlanInterface, args.bridgeInterface);
        } catch (VLanException ve) {
          result.ve = ve;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing createVLAN", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing createVLAN");
          oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class deleteVLAN implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        deleteVLAN_args args = new deleteVLAN_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        deleteVLAN_result result = new deleteVLAN_result();
        try {
          iface_.deleteVLAN(args.vlanTag, args.vlanInterface, args.bridgeInterface);
        } catch (VLanException ve) {
          result.ve = ve;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing deleteVLAN", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing deleteVLAN");
          oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class checkVLANConfiguration implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        checkVLANConfiguration_args args = new checkVLANConfiguration_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        checkVLANConfiguration_result result = new checkVLANConfiguration_result();
        try {
          iface_.checkVLANConfiguration();
        } catch (VLanException ve) {
          result.ve = ve;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing checkVLANConfiguration", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing checkVLANConfiguration");
          oprot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getInitiatorIQN implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getInitiatorIQN_args args = new getInitiatorIQN_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getInitiatorIQN_result result = new getInitiatorIQN_result();
        result.success = iface_.getInitiatorIQN();
        oprot.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class Service extends com.twitter.finagle.Service<byte[], byte[]> {
    private final ServiceIface iface;
    private final TProtocolFactory protocolFactory;
    protected HashMap<String, Function2<TProtocol, Integer, Future<byte[]>>> functionMap = new HashMap<String, Function2<TProtocol, Integer, Future<byte[]>>>();
    public Service(final ServiceIface iface, final TProtocolFactory protocolFactory) {
      this.iface = iface;
      this.protocolFactory = protocolFactory;
      functionMap.put("checkRimpConfiguration", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          checkRimpConfiguration_args args = new checkRimpConfiguration_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Void> future;
          try {
            future = iface.checkRimpConfiguration();
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Void, Future<byte[]>>() {
              public Future<byte[]> apply(Void value) {
                checkRimpConfiguration_result result = new checkRimpConfiguration_result();
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  checkRimpConfiguration_result result = new checkRimpConfiguration_result();
                  if (t instanceof RimpException) {
                    result.re = (RimpException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("checkRimpConfiguration", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("getDatastoreSize", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          getDatastoreSize_args args = new getDatastoreSize_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Long> future;
          try {
            future = iface.getDatastoreSize();
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Long, Future<byte[]>>() {
              public Future<byte[]> apply(Long value) {
                getDatastoreSize_result result = new getDatastoreSize_result();
                result.success = value;
                result.setSuccessIsSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  getDatastoreSize_result result = new getDatastoreSize_result();
                  if (t instanceof RimpException) {
                    result.re = (RimpException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("getDatastoreSize", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("getDiskFileSize", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          getDiskFileSize_args args = new getDiskFileSize_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Long> future;
          try {
            future = iface.getDiskFileSize(args.virtualImageDatastorePath);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Long, Future<byte[]>>() {
              public Future<byte[]> apply(Long value) {
                getDiskFileSize_result result = new getDiskFileSize_result();
                result.success = value;
                result.setSuccessIsSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  getDiskFileSize_result result = new getDiskFileSize_result();
                  if (t instanceof RimpException) {
                    result.re = (RimpException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("getDatastores", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          getDatastores_args args = new getDatastores_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<List<Datastore>> future;
          try {
            future = iface.getDatastores();
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<List<Datastore>, Future<byte[]>>() {
              public Future<byte[]> apply(List<Datastore> value) {
                getDatastores_result result = new getDatastores_result();
                result.success = value;
                result.setSuccessIsSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  getDatastores_result result = new getDatastores_result();
                  if (t instanceof RimpException) {
                    result.re = (RimpException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("getNetInterfaces", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          getNetInterfaces_args args = new getNetInterfaces_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<List<NetInterface>> future;
          try {
            future = iface.getNetInterfaces();
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<List<NetInterface>, Future<byte[]>>() {
              public Future<byte[]> apply(List<NetInterface> value) {
                getNetInterfaces_result result = new getNetInterfaces_result();
                result.success = value;
                result.setSuccessIsSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  getNetInterfaces_result result = new getNetInterfaces_result();
                  if (t instanceof RimpException) {
                    result.re = (RimpException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("copyFromRepositoryToDatastore", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          copyFromRepositoryToDatastore_args args = new copyFromRepositoryToDatastore_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Void> future;
          try {
            future = iface.copyFromRepositoryToDatastore(args.virtualImageRepositoryPath, args.datastorePath, args.virtualMachineUUID);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Void, Future<byte[]>>() {
              public Future<byte[]> apply(Void value) {
                copyFromRepositoryToDatastore_result result = new copyFromRepositoryToDatastore_result();
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  copyFromRepositoryToDatastore_result result = new copyFromRepositoryToDatastore_result();
                  if (t instanceof RimpException) {
                    result.re = (RimpException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("deleteVirtualImageFromDatastore", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          deleteVirtualImageFromDatastore_args args = new deleteVirtualImageFromDatastore_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Void> future;
          try {
            future = iface.deleteVirtualImageFromDatastore(args.datastorePath, args.virtualMachineUUID);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Void, Future<byte[]>>() {
              public Future<byte[]> apply(Void value) {
                deleteVirtualImageFromDatastore_result result = new deleteVirtualImageFromDatastore_result();
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  deleteVirtualImageFromDatastore_result result = new deleteVirtualImageFromDatastore_result();
                  if (t instanceof RimpException) {
                    result.re = (RimpException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("copyFromDatastoreToRepository", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          copyFromDatastoreToRepository_args args = new copyFromDatastoreToRepository_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Void> future;
          try {
            future = iface.copyFromDatastoreToRepository(args.virtualMachineUUID, args.snapshot, args.destinationRepositoryPath, args.sourceDatastorePath);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Void, Future<byte[]>>() {
              public Future<byte[]> apply(Void value) {
                copyFromDatastoreToRepository_result result = new copyFromDatastoreToRepository_result();
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  copyFromDatastoreToRepository_result result = new copyFromDatastoreToRepository_result();
                  if (t instanceof RimpException) {
                    result.re = (RimpException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("createVLAN", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          createVLAN_args args = new createVLAN_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Void> future;
          try {
            future = iface.createVLAN(args.vlanTag, args.vlanInterface, args.bridgeInterface);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Void, Future<byte[]>>() {
              public Future<byte[]> apply(Void value) {
                createVLAN_result result = new createVLAN_result();
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  createVLAN_result result = new createVLAN_result();
                  if (t instanceof VLanException) {
                    result.ve = (VLanException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("deleteVLAN", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          deleteVLAN_args args = new deleteVLAN_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Void> future;
          try {
            future = iface.deleteVLAN(args.vlanTag, args.vlanInterface, args.bridgeInterface);
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Void, Future<byte[]>>() {
              public Future<byte[]> apply(Void value) {
                deleteVLAN_result result = new deleteVLAN_result();
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  deleteVLAN_result result = new deleteVLAN_result();
                  if (t instanceof VLanException) {
                    result.ve = (VLanException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("checkVLANConfiguration", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          checkVLANConfiguration_args args = new checkVLANConfiguration_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<Void> future;
          try {
            future = iface.checkVLANConfiguration();
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<Void, Future<byte[]>>() {
              public Future<byte[]> apply(Void value) {
                checkVLANConfiguration_result result = new checkVLANConfiguration_result();
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                try {
                  checkVLANConfiguration_result result = new checkVLANConfiguration_result();
                  if (t instanceof VLanException) {
                    result.ve = (VLanException)t;
                  }
                  else {
                    return Future.exception(t);
                  }
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                  oprot.writeMessageBegin(new TMessage("checkVLANConfiguration", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                  oprot.getTransport().flush();
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
      functionMap.put("getInitiatorIQN", new Function2<TProtocol, Integer, Future<byte[]>>() {
        public Future<byte[]> apply(final TProtocol iprot, final Integer seqid) {
          getInitiatorIQN_args args = new getInitiatorIQN_args();
          try {
            args.read(iprot);
          } catch (TProtocolException e) {
            try {
              iprot.readMessageEnd();
              TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
              TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
              TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          
              oprot.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.EXCEPTION, seqid));
              x.write(oprot);
              oprot.writeMessageEnd();
              oprot.getTransport().flush();
              byte[] buffer = Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length());
              return Future.value(buffer);
            } catch (Exception e1) {
              return Future.exception(e1);
            }
          } catch (Exception e) {
            return Future.exception(e);
          }
          
          try {
            iprot.readMessageEnd();
          } catch (Exception e) {
            return Future.exception(e);
          }
          Future<String> future;
          try {
            future = iface.getInitiatorIQN();
          } catch (Exception e) {
            future = Future.exception(e);
          }
          try {
            return future.flatMap(new Function<String, Future<byte[]>>() {
              public Future<byte[]> apply(String value) {
                getInitiatorIQN_result result = new getInitiatorIQN_result();
                result.success = value;
                result.setSuccessIsSet(true);
          
                try {
                  TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
                  TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
                   
                  oprot.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.REPLY, seqid));
                  result.write(oprot);
                  oprot.writeMessageEnd();
                   
                  return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
                } catch (Exception e) {
                  return Future.exception(e);
                }
              }
            }).rescue(new Function<Throwable, Future<byte[]>>() {
              public Future<byte[]> apply(Throwable t) {
                return Future.exception(t);
              }
            });
          } catch (Exception e) {
            return Future.exception(e);
          }
        }
      });
      
    }
    
    public Future<byte[]> apply(byte[] request) {
      TTransport inputTransport = new TMemoryInputTransport(request);
      TProtocol iprot = protocolFactory.getProtocol(inputTransport);
    
      TMessage msg;
      try {
        msg = iprot.readMessageBegin();
      } catch (Exception e) {
        return Future.exception(e);
      }
    
      Function2<TProtocol, Integer, Future<byte[]>> fn = functionMap.get(msg.name);
      if (fn == null) {
        try {
          TProtocolUtil.skip(iprot, TType.STRUCT);
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
          TMemoryBuffer memoryBuffer = new TMemoryBuffer(512);
          TProtocol oprot = protocolFactory.getProtocol(memoryBuffer);
          oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return Future.value(Arrays.copyOfRange(memoryBuffer.getArray(), 0, memoryBuffer.length()));
        } catch (Exception e) {
          return Future.exception(e);
        }
      }
    
      return fn.apply(iprot, msg.seqid);
    }

  }

  public static class checkRimpConfiguration_args implements TBase<checkRimpConfiguration_args, checkRimpConfiguration_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkRimpConfiguration_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkRimpConfiguration_args.class, metaDataMap);
    }

    public checkRimpConfiguration_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkRimpConfiguration_args(checkRimpConfiguration_args other) {
    }

    public checkRimpConfiguration_args deepCopy() {
      return new checkRimpConfiguration_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkRimpConfiguration_args)
        return this.equals((checkRimpConfiguration_args)that);
      return false;
    }

    public boolean equals(checkRimpConfiguration_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkRimpConfiguration_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkRimpConfiguration_args typedOther = (checkRimpConfiguration_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkRimpConfiguration_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkRimpConfiguration_result implements TBase<checkRimpConfiguration_result, checkRimpConfiguration_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkRimpConfiguration_result");

    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RE((short)1, "re");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // RE
            return RE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkRimpConfiguration_result.class, metaDataMap);
    }

    public checkRimpConfiguration_result() {
    }

    public checkRimpConfiguration_result(
      RimpException re)
    {
      this();
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkRimpConfiguration_result(checkRimpConfiguration_result other) {
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public checkRimpConfiguration_result deepCopy() {
      return new checkRimpConfiguration_result(this);
    }

    @Override
    public void clear() {
      this.re = null;
    }

    public RimpException getRe() {
      return this.re;
    }

    public checkRimpConfiguration_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkRimpConfiguration_result)
        return this.equals((checkRimpConfiguration_result)that);
      return false;
    }

    public boolean equals(checkRimpConfiguration_result that) {
      if (that == null)
        return false;

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkRimpConfiguration_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkRimpConfiguration_result typedOther = (checkRimpConfiguration_result)other;

      lastComparison = Boolean.valueOf(isSetRe()).compareTo(typedOther.isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRe()) {
        lastComparison = TBaseHelper.compareTo(this.re, typedOther.re);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // RE
            if (field.type == TType.STRUCT) {
              this.re = new RimpException();
              this.re.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkRimpConfiguration_result(");
      boolean first = true;

      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDatastoreSize_args implements TBase<getDatastoreSize_args, getDatastoreSize_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatastoreSize_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDatastoreSize_args.class, metaDataMap);
    }

    public getDatastoreSize_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatastoreSize_args(getDatastoreSize_args other) {
    }

    public getDatastoreSize_args deepCopy() {
      return new getDatastoreSize_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatastoreSize_args)
        return this.equals((getDatastoreSize_args)that);
      return false;
    }

    public boolean equals(getDatastoreSize_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDatastoreSize_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDatastoreSize_args typedOther = (getDatastoreSize_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatastoreSize_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDatastoreSize_result implements TBase<getDatastoreSize_result, getDatastoreSize_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatastoreSize_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public long success;
    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      RE((short)1, "re");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // RE
            return RE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      tmpMap.put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDatastoreSize_result.class, metaDataMap);
    }

    public getDatastoreSize_result() {
    }

    public getDatastoreSize_result(
      long success,
      RimpException re)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatastoreSize_result(getDatastoreSize_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public getDatastoreSize_result deepCopy() {
      return new getDatastoreSize_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.re = null;
    }

    public long getSuccess() {
      return this.success;
    }

    public getDatastoreSize_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public RimpException getRe() {
      return this.re;
    }

    public getDatastoreSize_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatastoreSize_result)
        return this.equals((getDatastoreSize_result)that);
      return false;
    }

    public boolean equals(getDatastoreSize_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDatastoreSize_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDatastoreSize_result typedOther = (getDatastoreSize_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRe()).compareTo(typedOther.isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRe()) {
        lastComparison = TBaseHelper.compareTo(this.re, typedOther.re);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // RE
            if (field.type == TType.STRUCT) {
              this.re = new RimpException();
              this.re.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatastoreSize_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDiskFileSize_args implements TBase<getDiskFileSize_args, getDiskFileSize_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDiskFileSize_args");

    private static final TField VIRTUAL_IMAGE_DATASTORE_PATH_FIELD_DESC = new TField("virtualImageDatastorePath", TType.STRING, (short)1);

    public String virtualImageDatastorePath;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VIRTUAL_IMAGE_DATASTORE_PATH((short)1, "virtualImageDatastorePath");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // VIRTUAL_IMAGE_DATASTORE_PATH
            return VIRTUAL_IMAGE_DATASTORE_PATH;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.VIRTUAL_IMAGE_DATASTORE_PATH, new FieldMetaData("virtualImageDatastorePath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDiskFileSize_args.class, metaDataMap);
    }

    public getDiskFileSize_args() {
    }

    public getDiskFileSize_args(
      String virtualImageDatastorePath)
    {
      this();
      this.virtualImageDatastorePath = virtualImageDatastorePath;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDiskFileSize_args(getDiskFileSize_args other) {
      if (other.isSetVirtualImageDatastorePath()) {
        this.virtualImageDatastorePath = other.virtualImageDatastorePath;
      }
    }

    public getDiskFileSize_args deepCopy() {
      return new getDiskFileSize_args(this);
    }

    @Override
    public void clear() {
      this.virtualImageDatastorePath = null;
    }

    public String getVirtualImageDatastorePath() {
      return this.virtualImageDatastorePath;
    }

    public getDiskFileSize_args setVirtualImageDatastorePath(String virtualImageDatastorePath) {
      this.virtualImageDatastorePath = virtualImageDatastorePath;
      return this;
    }

    public void unsetVirtualImageDatastorePath() {
      this.virtualImageDatastorePath = null;
    }

    /** Returns true if field virtualImageDatastorePath is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualImageDatastorePath() {
      return this.virtualImageDatastorePath != null;
    }

    public void setVirtualImageDatastorePathIsSet(boolean value) {
      if (!value) {
        this.virtualImageDatastorePath = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VIRTUAL_IMAGE_DATASTORE_PATH:
        if (value == null) {
          unsetVirtualImageDatastorePath();
        } else {
          setVirtualImageDatastorePath((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VIRTUAL_IMAGE_DATASTORE_PATH:
        return getVirtualImageDatastorePath();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case VIRTUAL_IMAGE_DATASTORE_PATH:
        return isSetVirtualImageDatastorePath();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDiskFileSize_args)
        return this.equals((getDiskFileSize_args)that);
      return false;
    }

    public boolean equals(getDiskFileSize_args that) {
      if (that == null)
        return false;

      boolean this_present_virtualImageDatastorePath = true && this.isSetVirtualImageDatastorePath();
      boolean that_present_virtualImageDatastorePath = true && that.isSetVirtualImageDatastorePath();
      if (this_present_virtualImageDatastorePath || that_present_virtualImageDatastorePath) {
        if (!(this_present_virtualImageDatastorePath && that_present_virtualImageDatastorePath))
          return false;
        if (!this.virtualImageDatastorePath.equals(that.virtualImageDatastorePath))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDiskFileSize_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDiskFileSize_args typedOther = (getDiskFileSize_args)other;

      lastComparison = Boolean.valueOf(isSetVirtualImageDatastorePath()).compareTo(typedOther.isSetVirtualImageDatastorePath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVirtualImageDatastorePath()) {
        lastComparison = TBaseHelper.compareTo(this.virtualImageDatastorePath, typedOther.virtualImageDatastorePath);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VIRTUAL_IMAGE_DATASTORE_PATH
            if (field.type == TType.STRING) {
              this.virtualImageDatastorePath = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.virtualImageDatastorePath != null) {
        oprot.writeFieldBegin(VIRTUAL_IMAGE_DATASTORE_PATH_FIELD_DESC);
        oprot.writeString(this.virtualImageDatastorePath);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDiskFileSize_args(");
      boolean first = true;

      sb.append("virtualImageDatastorePath:");
      if (this.virtualImageDatastorePath == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualImageDatastorePath);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDiskFileSize_result implements TBase<getDiskFileSize_result, getDiskFileSize_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDiskFileSize_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I64, (short)0);
    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public long success;
    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      RE((short)1, "re");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // RE
            return RE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      tmpMap.put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDiskFileSize_result.class, metaDataMap);
    }

    public getDiskFileSize_result() {
    }

    public getDiskFileSize_result(
      long success,
      RimpException re)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDiskFileSize_result(getDiskFileSize_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public getDiskFileSize_result deepCopy() {
      return new getDiskFileSize_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.re = null;
    }

    public long getSuccess() {
      return this.success;
    }

    public getDiskFileSize_result setSuccess(long success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public RimpException getRe() {
      return this.re;
    }

    public getDiskFileSize_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Long)value);
        }
        break;

      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Long(getSuccess());

      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDiskFileSize_result)
        return this.equals((getDiskFileSize_result)that);
      return false;
    }

    public boolean equals(getDiskFileSize_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDiskFileSize_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDiskFileSize_result typedOther = (getDiskFileSize_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRe()).compareTo(typedOther.isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRe()) {
        lastComparison = TBaseHelper.compareTo(this.re, typedOther.re);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I64) {
              this.success = iprot.readI64();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // RE
            if (field.type == TType.STRUCT) {
              this.re = new RimpException();
              this.re.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI64(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDiskFileSize_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDatastores_args implements TBase<getDatastores_args, getDatastores_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatastores_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDatastores_args.class, metaDataMap);
    }

    public getDatastores_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatastores_args(getDatastores_args other) {
    }

    public getDatastores_args deepCopy() {
      return new getDatastores_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatastores_args)
        return this.equals((getDatastores_args)that);
      return false;
    }

    public boolean equals(getDatastores_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDatastores_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDatastores_args typedOther = (getDatastores_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatastores_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDatastores_result implements TBase<getDatastores_result, getDatastores_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDatastores_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public List<Datastore> success;
    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      RE((short)1, "re");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // RE
            return RE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Datastore.class))));
      tmpMap.put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDatastores_result.class, metaDataMap);
    }

    public getDatastores_result() {
    }

    public getDatastores_result(
      List<Datastore> success,
      RimpException re)
    {
      this();
      this.success = success;
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDatastores_result(getDatastores_result other) {
      if (other.isSetSuccess()) {
        List<Datastore> __this__success = new ArrayList<Datastore>();
        for (Datastore other_element : other.success) {
          __this__success.add(new Datastore(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public getDatastores_result deepCopy() {
      return new getDatastores_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.re = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Datastore> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Datastore elem) {
      if (this.success == null) {
        this.success = new ArrayList<Datastore>();
      }
      this.success.add(elem);
    }

    public List<Datastore> getSuccess() {
      return this.success;
    }

    public getDatastores_result setSuccess(List<Datastore> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RimpException getRe() {
      return this.re;
    }

    public getDatastores_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Datastore>)value);
        }
        break;

      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDatastores_result)
        return this.equals((getDatastores_result)that);
      return false;
    }

    public boolean equals(getDatastores_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDatastores_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDatastores_result typedOther = (getDatastores_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRe()).compareTo(typedOther.isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRe()) {
        lastComparison = TBaseHelper.compareTo(this.re, typedOther.re);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list0 = iprot.readListBegin();
                this.success = new ArrayList<Datastore>(_list0.size);
                for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                {
                  Datastore _elem2;
                  _elem2 = new Datastore();
                  _elem2.read(iprot);
                  this.success.add(_elem2);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // RE
            if (field.type == TType.STRUCT) {
              this.re = new RimpException();
              this.re.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Datastore _iter3 : this.success)
          {
            _iter3.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDatastores_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getNetInterfaces_args implements TBase<getNetInterfaces_args, getNetInterfaces_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getNetInterfaces_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getNetInterfaces_args.class, metaDataMap);
    }

    public getNetInterfaces_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getNetInterfaces_args(getNetInterfaces_args other) {
    }

    public getNetInterfaces_args deepCopy() {
      return new getNetInterfaces_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getNetInterfaces_args)
        return this.equals((getNetInterfaces_args)that);
      return false;
    }

    public boolean equals(getNetInterfaces_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getNetInterfaces_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getNetInterfaces_args typedOther = (getNetInterfaces_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getNetInterfaces_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getNetInterfaces_result implements TBase<getNetInterfaces_result, getNetInterfaces_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getNetInterfaces_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public List<NetInterface> success;
    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      RE((short)1, "re");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // RE
            return RE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, NetInterface.class))));
      tmpMap.put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getNetInterfaces_result.class, metaDataMap);
    }

    public getNetInterfaces_result() {
    }

    public getNetInterfaces_result(
      List<NetInterface> success,
      RimpException re)
    {
      this();
      this.success = success;
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getNetInterfaces_result(getNetInterfaces_result other) {
      if (other.isSetSuccess()) {
        List<NetInterface> __this__success = new ArrayList<NetInterface>();
        for (NetInterface other_element : other.success) {
          __this__success.add(new NetInterface(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public getNetInterfaces_result deepCopy() {
      return new getNetInterfaces_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.re = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<NetInterface> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(NetInterface elem) {
      if (this.success == null) {
        this.success = new ArrayList<NetInterface>();
      }
      this.success.add(elem);
    }

    public List<NetInterface> getSuccess() {
      return this.success;
    }

    public getNetInterfaces_result setSuccess(List<NetInterface> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public RimpException getRe() {
      return this.re;
    }

    public getNetInterfaces_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<NetInterface>)value);
        }
        break;

      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getNetInterfaces_result)
        return this.equals((getNetInterfaces_result)that);
      return false;
    }

    public boolean equals(getNetInterfaces_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getNetInterfaces_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getNetInterfaces_result typedOther = (getNetInterfaces_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetRe()).compareTo(typedOther.isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRe()) {
        lastComparison = TBaseHelper.compareTo(this.re, typedOther.re);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list4 = iprot.readListBegin();
                this.success = new ArrayList<NetInterface>(_list4.size);
                for (int _i5 = 0; _i5 < _list4.size; ++_i5)
                {
                  NetInterface _elem6;
                  _elem6 = new NetInterface();
                  _elem6.read(iprot);
                  this.success.add(_elem6);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // RE
            if (field.type == TType.STRUCT) {
              this.re = new RimpException();
              this.re.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (NetInterface _iter7 : this.success)
          {
            _iter7.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getNetInterfaces_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class copyFromRepositoryToDatastore_args implements TBase<copyFromRepositoryToDatastore_args, copyFromRepositoryToDatastore_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("copyFromRepositoryToDatastore_args");

    private static final TField VIRTUAL_IMAGE_REPOSITORY_PATH_FIELD_DESC = new TField("virtualImageRepositoryPath", TType.STRING, (short)1);
    private static final TField DATASTORE_PATH_FIELD_DESC = new TField("datastorePath", TType.STRING, (short)2);
    private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC = new TField("virtualMachineUUID", TType.STRING, (short)3);

    public String virtualImageRepositoryPath;
    public String datastorePath;
    public String virtualMachineUUID;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VIRTUAL_IMAGE_REPOSITORY_PATH((short)1, "virtualImageRepositoryPath"),
      DATASTORE_PATH((short)2, "datastorePath"),
      VIRTUAL_MACHINE_UUID((short)3, "virtualMachineUUID");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // VIRTUAL_IMAGE_REPOSITORY_PATH
            return VIRTUAL_IMAGE_REPOSITORY_PATH;
          case 2: // DATASTORE_PATH
            return DATASTORE_PATH;
          case 3: // VIRTUAL_MACHINE_UUID
            return VIRTUAL_MACHINE_UUID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.VIRTUAL_IMAGE_REPOSITORY_PATH, new FieldMetaData("virtualImageRepositoryPath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DATASTORE_PATH, new FieldMetaData("datastorePath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(copyFromRepositoryToDatastore_args.class, metaDataMap);
    }

    public copyFromRepositoryToDatastore_args() {
    }

    public copyFromRepositoryToDatastore_args(
      String virtualImageRepositoryPath,
      String datastorePath,
      String virtualMachineUUID)
    {
      this();
      this.virtualImageRepositoryPath = virtualImageRepositoryPath;
      this.datastorePath = datastorePath;
      this.virtualMachineUUID = virtualMachineUUID;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public copyFromRepositoryToDatastore_args(copyFromRepositoryToDatastore_args other) {
      if (other.isSetVirtualImageRepositoryPath()) {
        this.virtualImageRepositoryPath = other.virtualImageRepositoryPath;
      }
      if (other.isSetDatastorePath()) {
        this.datastorePath = other.datastorePath;
      }
      if (other.isSetVirtualMachineUUID()) {
        this.virtualMachineUUID = other.virtualMachineUUID;
      }
    }

    public copyFromRepositoryToDatastore_args deepCopy() {
      return new copyFromRepositoryToDatastore_args(this);
    }

    @Override
    public void clear() {
      this.virtualImageRepositoryPath = null;
      this.datastorePath = null;
      this.virtualMachineUUID = null;
    }

    public String getVirtualImageRepositoryPath() {
      return this.virtualImageRepositoryPath;
    }

    public copyFromRepositoryToDatastore_args setVirtualImageRepositoryPath(String virtualImageRepositoryPath) {
      this.virtualImageRepositoryPath = virtualImageRepositoryPath;
      return this;
    }

    public void unsetVirtualImageRepositoryPath() {
      this.virtualImageRepositoryPath = null;
    }

    /** Returns true if field virtualImageRepositoryPath is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualImageRepositoryPath() {
      return this.virtualImageRepositoryPath != null;
    }

    public void setVirtualImageRepositoryPathIsSet(boolean value) {
      if (!value) {
        this.virtualImageRepositoryPath = null;
      }
    }

    public String getDatastorePath() {
      return this.datastorePath;
    }

    public copyFromRepositoryToDatastore_args setDatastorePath(String datastorePath) {
      this.datastorePath = datastorePath;
      return this;
    }

    public void unsetDatastorePath() {
      this.datastorePath = null;
    }

    /** Returns true if field datastorePath is set (has been asigned a value) and false otherwise */
    public boolean isSetDatastorePath() {
      return this.datastorePath != null;
    }

    public void setDatastorePathIsSet(boolean value) {
      if (!value) {
        this.datastorePath = null;
      }
    }

    public String getVirtualMachineUUID() {
      return this.virtualMachineUUID;
    }

    public copyFromRepositoryToDatastore_args setVirtualMachineUUID(String virtualMachineUUID) {
      this.virtualMachineUUID = virtualMachineUUID;
      return this;
    }

    public void unsetVirtualMachineUUID() {
      this.virtualMachineUUID = null;
    }

    /** Returns true if field virtualMachineUUID is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualMachineUUID() {
      return this.virtualMachineUUID != null;
    }

    public void setVirtualMachineUUIDIsSet(boolean value) {
      if (!value) {
        this.virtualMachineUUID = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VIRTUAL_IMAGE_REPOSITORY_PATH:
        if (value == null) {
          unsetVirtualImageRepositoryPath();
        } else {
          setVirtualImageRepositoryPath((String)value);
        }
        break;

      case DATASTORE_PATH:
        if (value == null) {
          unsetDatastorePath();
        } else {
          setDatastorePath((String)value);
        }
        break;

      case VIRTUAL_MACHINE_UUID:
        if (value == null) {
          unsetVirtualMachineUUID();
        } else {
          setVirtualMachineUUID((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VIRTUAL_IMAGE_REPOSITORY_PATH:
        return getVirtualImageRepositoryPath();

      case DATASTORE_PATH:
        return getDatastorePath();

      case VIRTUAL_MACHINE_UUID:
        return getVirtualMachineUUID();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case VIRTUAL_IMAGE_REPOSITORY_PATH:
        return isSetVirtualImageRepositoryPath();
      case DATASTORE_PATH:
        return isSetDatastorePath();
      case VIRTUAL_MACHINE_UUID:
        return isSetVirtualMachineUUID();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof copyFromRepositoryToDatastore_args)
        return this.equals((copyFromRepositoryToDatastore_args)that);
      return false;
    }

    public boolean equals(copyFromRepositoryToDatastore_args that) {
      if (that == null)
        return false;

      boolean this_present_virtualImageRepositoryPath = true && this.isSetVirtualImageRepositoryPath();
      boolean that_present_virtualImageRepositoryPath = true && that.isSetVirtualImageRepositoryPath();
      if (this_present_virtualImageRepositoryPath || that_present_virtualImageRepositoryPath) {
        if (!(this_present_virtualImageRepositoryPath && that_present_virtualImageRepositoryPath))
          return false;
        if (!this.virtualImageRepositoryPath.equals(that.virtualImageRepositoryPath))
          return false;
      }

      boolean this_present_datastorePath = true && this.isSetDatastorePath();
      boolean that_present_datastorePath = true && that.isSetDatastorePath();
      if (this_present_datastorePath || that_present_datastorePath) {
        if (!(this_present_datastorePath && that_present_datastorePath))
          return false;
        if (!this.datastorePath.equals(that.datastorePath))
          return false;
      }

      boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
      boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
      if (this_present_virtualMachineUUID || that_present_virtualMachineUUID) {
        if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
          return false;
        if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(copyFromRepositoryToDatastore_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      copyFromRepositoryToDatastore_args typedOther = (copyFromRepositoryToDatastore_args)other;

      lastComparison = Boolean.valueOf(isSetVirtualImageRepositoryPath()).compareTo(typedOther.isSetVirtualImageRepositoryPath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVirtualImageRepositoryPath()) {
        lastComparison = TBaseHelper.compareTo(this.virtualImageRepositoryPath, typedOther.virtualImageRepositoryPath);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDatastorePath()).compareTo(typedOther.isSetDatastorePath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDatastorePath()) {
        lastComparison = TBaseHelper.compareTo(this.datastorePath, typedOther.datastorePath);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(typedOther.isSetVirtualMachineUUID());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVirtualMachineUUID()) {
        lastComparison = TBaseHelper.compareTo(this.virtualMachineUUID, typedOther.virtualMachineUUID);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VIRTUAL_IMAGE_REPOSITORY_PATH
            if (field.type == TType.STRING) {
              this.virtualImageRepositoryPath = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // DATASTORE_PATH
            if (field.type == TType.STRING) {
              this.datastorePath = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // VIRTUAL_MACHINE_UUID
            if (field.type == TType.STRING) {
              this.virtualMachineUUID = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.virtualImageRepositoryPath != null) {
        oprot.writeFieldBegin(VIRTUAL_IMAGE_REPOSITORY_PATH_FIELD_DESC);
        oprot.writeString(this.virtualImageRepositoryPath);
        oprot.writeFieldEnd();
      }
      if (this.datastorePath != null) {
        oprot.writeFieldBegin(DATASTORE_PATH_FIELD_DESC);
        oprot.writeString(this.datastorePath);
        oprot.writeFieldEnd();
      }
      if (this.virtualMachineUUID != null) {
        oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
        oprot.writeString(this.virtualMachineUUID);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("copyFromRepositoryToDatastore_args(");
      boolean first = true;

      sb.append("virtualImageRepositoryPath:");
      if (this.virtualImageRepositoryPath == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualImageRepositoryPath);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("datastorePath:");
      if (this.datastorePath == null) {
        sb.append("null");
      } else {
        sb.append(this.datastorePath);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("virtualMachineUUID:");
      if (this.virtualMachineUUID == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualMachineUUID);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class copyFromRepositoryToDatastore_result implements TBase<copyFromRepositoryToDatastore_result, copyFromRepositoryToDatastore_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("copyFromRepositoryToDatastore_result");

    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RE((short)1, "re");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // RE
            return RE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(copyFromRepositoryToDatastore_result.class, metaDataMap);
    }

    public copyFromRepositoryToDatastore_result() {
    }

    public copyFromRepositoryToDatastore_result(
      RimpException re)
    {
      this();
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public copyFromRepositoryToDatastore_result(copyFromRepositoryToDatastore_result other) {
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public copyFromRepositoryToDatastore_result deepCopy() {
      return new copyFromRepositoryToDatastore_result(this);
    }

    @Override
    public void clear() {
      this.re = null;
    }

    public RimpException getRe() {
      return this.re;
    }

    public copyFromRepositoryToDatastore_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof copyFromRepositoryToDatastore_result)
        return this.equals((copyFromRepositoryToDatastore_result)that);
      return false;
    }

    public boolean equals(copyFromRepositoryToDatastore_result that) {
      if (that == null)
        return false;

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(copyFromRepositoryToDatastore_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      copyFromRepositoryToDatastore_result typedOther = (copyFromRepositoryToDatastore_result)other;

      lastComparison = Boolean.valueOf(isSetRe()).compareTo(typedOther.isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRe()) {
        lastComparison = TBaseHelper.compareTo(this.re, typedOther.re);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // RE
            if (field.type == TType.STRUCT) {
              this.re = new RimpException();
              this.re.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("copyFromRepositoryToDatastore_result(");
      boolean first = true;

      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteVirtualImageFromDatastore_args implements TBase<deleteVirtualImageFromDatastore_args, deleteVirtualImageFromDatastore_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteVirtualImageFromDatastore_args");

    private static final TField DATASTORE_PATH_FIELD_DESC = new TField("datastorePath", TType.STRING, (short)1);
    private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC = new TField("virtualMachineUUID", TType.STRING, (short)2);

    public String datastorePath;
    public String virtualMachineUUID;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      DATASTORE_PATH((short)1, "datastorePath"),
      VIRTUAL_MACHINE_UUID((short)2, "virtualMachineUUID");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // DATASTORE_PATH
            return DATASTORE_PATH;
          case 2: // VIRTUAL_MACHINE_UUID
            return VIRTUAL_MACHINE_UUID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.DATASTORE_PATH, new FieldMetaData("datastorePath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteVirtualImageFromDatastore_args.class, metaDataMap);
    }

    public deleteVirtualImageFromDatastore_args() {
    }

    public deleteVirtualImageFromDatastore_args(
      String datastorePath,
      String virtualMachineUUID)
    {
      this();
      this.datastorePath = datastorePath;
      this.virtualMachineUUID = virtualMachineUUID;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteVirtualImageFromDatastore_args(deleteVirtualImageFromDatastore_args other) {
      if (other.isSetDatastorePath()) {
        this.datastorePath = other.datastorePath;
      }
      if (other.isSetVirtualMachineUUID()) {
        this.virtualMachineUUID = other.virtualMachineUUID;
      }
    }

    public deleteVirtualImageFromDatastore_args deepCopy() {
      return new deleteVirtualImageFromDatastore_args(this);
    }

    @Override
    public void clear() {
      this.datastorePath = null;
      this.virtualMachineUUID = null;
    }

    public String getDatastorePath() {
      return this.datastorePath;
    }

    public deleteVirtualImageFromDatastore_args setDatastorePath(String datastorePath) {
      this.datastorePath = datastorePath;
      return this;
    }

    public void unsetDatastorePath() {
      this.datastorePath = null;
    }

    /** Returns true if field datastorePath is set (has been asigned a value) and false otherwise */
    public boolean isSetDatastorePath() {
      return this.datastorePath != null;
    }

    public void setDatastorePathIsSet(boolean value) {
      if (!value) {
        this.datastorePath = null;
      }
    }

    public String getVirtualMachineUUID() {
      return this.virtualMachineUUID;
    }

    public deleteVirtualImageFromDatastore_args setVirtualMachineUUID(String virtualMachineUUID) {
      this.virtualMachineUUID = virtualMachineUUID;
      return this;
    }

    public void unsetVirtualMachineUUID() {
      this.virtualMachineUUID = null;
    }

    /** Returns true if field virtualMachineUUID is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualMachineUUID() {
      return this.virtualMachineUUID != null;
    }

    public void setVirtualMachineUUIDIsSet(boolean value) {
      if (!value) {
        this.virtualMachineUUID = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case DATASTORE_PATH:
        if (value == null) {
          unsetDatastorePath();
        } else {
          setDatastorePath((String)value);
        }
        break;

      case VIRTUAL_MACHINE_UUID:
        if (value == null) {
          unsetVirtualMachineUUID();
        } else {
          setVirtualMachineUUID((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case DATASTORE_PATH:
        return getDatastorePath();

      case VIRTUAL_MACHINE_UUID:
        return getVirtualMachineUUID();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case DATASTORE_PATH:
        return isSetDatastorePath();
      case VIRTUAL_MACHINE_UUID:
        return isSetVirtualMachineUUID();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteVirtualImageFromDatastore_args)
        return this.equals((deleteVirtualImageFromDatastore_args)that);
      return false;
    }

    public boolean equals(deleteVirtualImageFromDatastore_args that) {
      if (that == null)
        return false;

      boolean this_present_datastorePath = true && this.isSetDatastorePath();
      boolean that_present_datastorePath = true && that.isSetDatastorePath();
      if (this_present_datastorePath || that_present_datastorePath) {
        if (!(this_present_datastorePath && that_present_datastorePath))
          return false;
        if (!this.datastorePath.equals(that.datastorePath))
          return false;
      }

      boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
      boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
      if (this_present_virtualMachineUUID || that_present_virtualMachineUUID) {
        if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
          return false;
        if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteVirtualImageFromDatastore_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteVirtualImageFromDatastore_args typedOther = (deleteVirtualImageFromDatastore_args)other;

      lastComparison = Boolean.valueOf(isSetDatastorePath()).compareTo(typedOther.isSetDatastorePath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDatastorePath()) {
        lastComparison = TBaseHelper.compareTo(this.datastorePath, typedOther.datastorePath);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(typedOther.isSetVirtualMachineUUID());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVirtualMachineUUID()) {
        lastComparison = TBaseHelper.compareTo(this.virtualMachineUUID, typedOther.virtualMachineUUID);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // DATASTORE_PATH
            if (field.type == TType.STRING) {
              this.datastorePath = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // VIRTUAL_MACHINE_UUID
            if (field.type == TType.STRING) {
              this.virtualMachineUUID = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.datastorePath != null) {
        oprot.writeFieldBegin(DATASTORE_PATH_FIELD_DESC);
        oprot.writeString(this.datastorePath);
        oprot.writeFieldEnd();
      }
      if (this.virtualMachineUUID != null) {
        oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
        oprot.writeString(this.virtualMachineUUID);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteVirtualImageFromDatastore_args(");
      boolean first = true;

      sb.append("datastorePath:");
      if (this.datastorePath == null) {
        sb.append("null");
      } else {
        sb.append(this.datastorePath);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("virtualMachineUUID:");
      if (this.virtualMachineUUID == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualMachineUUID);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteVirtualImageFromDatastore_result implements TBase<deleteVirtualImageFromDatastore_result, deleteVirtualImageFromDatastore_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteVirtualImageFromDatastore_result");

    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RE((short)1, "re");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // RE
            return RE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteVirtualImageFromDatastore_result.class, metaDataMap);
    }

    public deleteVirtualImageFromDatastore_result() {
    }

    public deleteVirtualImageFromDatastore_result(
      RimpException re)
    {
      this();
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteVirtualImageFromDatastore_result(deleteVirtualImageFromDatastore_result other) {
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public deleteVirtualImageFromDatastore_result deepCopy() {
      return new deleteVirtualImageFromDatastore_result(this);
    }

    @Override
    public void clear() {
      this.re = null;
    }

    public RimpException getRe() {
      return this.re;
    }

    public deleteVirtualImageFromDatastore_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteVirtualImageFromDatastore_result)
        return this.equals((deleteVirtualImageFromDatastore_result)that);
      return false;
    }

    public boolean equals(deleteVirtualImageFromDatastore_result that) {
      if (that == null)
        return false;

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteVirtualImageFromDatastore_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteVirtualImageFromDatastore_result typedOther = (deleteVirtualImageFromDatastore_result)other;

      lastComparison = Boolean.valueOf(isSetRe()).compareTo(typedOther.isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRe()) {
        lastComparison = TBaseHelper.compareTo(this.re, typedOther.re);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // RE
            if (field.type == TType.STRUCT) {
              this.re = new RimpException();
              this.re.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteVirtualImageFromDatastore_result(");
      boolean first = true;

      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class copyFromDatastoreToRepository_args implements TBase<copyFromDatastoreToRepository_args, copyFromDatastoreToRepository_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("copyFromDatastoreToRepository_args");

    private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC = new TField("virtualMachineUUID", TType.STRING, (short)1);
    private static final TField SNAPSHOT_FIELD_DESC = new TField("snapshot", TType.STRING, (short)2);
    private static final TField DESTINATION_REPOSITORY_PATH_FIELD_DESC = new TField("destinationRepositoryPath", TType.STRING, (short)3);
    private static final TField SOURCE_DATASTORE_PATH_FIELD_DESC = new TField("sourceDatastorePath", TType.STRING, (short)4);

    public String virtualMachineUUID;
    public String snapshot;
    public String destinationRepositoryPath;
    public String sourceDatastorePath;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VIRTUAL_MACHINE_UUID((short)1, "virtualMachineUUID"),
      SNAPSHOT((short)2, "snapshot"),
      DESTINATION_REPOSITORY_PATH((short)3, "destinationRepositoryPath"),
      SOURCE_DATASTORE_PATH((short)4, "sourceDatastorePath");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // VIRTUAL_MACHINE_UUID
            return VIRTUAL_MACHINE_UUID;
          case 2: // SNAPSHOT
            return SNAPSHOT;
          case 3: // DESTINATION_REPOSITORY_PATH
            return DESTINATION_REPOSITORY_PATH;
          case 4: // SOURCE_DATASTORE_PATH
            return SOURCE_DATASTORE_PATH;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SNAPSHOT, new FieldMetaData("snapshot", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.DESTINATION_REPOSITORY_PATH, new FieldMetaData("destinationRepositoryPath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SOURCE_DATASTORE_PATH, new FieldMetaData("sourceDatastorePath", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(copyFromDatastoreToRepository_args.class, metaDataMap);
    }

    public copyFromDatastoreToRepository_args() {
    }

    public copyFromDatastoreToRepository_args(
      String virtualMachineUUID,
      String snapshot,
      String destinationRepositoryPath,
      String sourceDatastorePath)
    {
      this();
      this.virtualMachineUUID = virtualMachineUUID;
      this.snapshot = snapshot;
      this.destinationRepositoryPath = destinationRepositoryPath;
      this.sourceDatastorePath = sourceDatastorePath;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public copyFromDatastoreToRepository_args(copyFromDatastoreToRepository_args other) {
      if (other.isSetVirtualMachineUUID()) {
        this.virtualMachineUUID = other.virtualMachineUUID;
      }
      if (other.isSetSnapshot()) {
        this.snapshot = other.snapshot;
      }
      if (other.isSetDestinationRepositoryPath()) {
        this.destinationRepositoryPath = other.destinationRepositoryPath;
      }
      if (other.isSetSourceDatastorePath()) {
        this.sourceDatastorePath = other.sourceDatastorePath;
      }
    }

    public copyFromDatastoreToRepository_args deepCopy() {
      return new copyFromDatastoreToRepository_args(this);
    }

    @Override
    public void clear() {
      this.virtualMachineUUID = null;
      this.snapshot = null;
      this.destinationRepositoryPath = null;
      this.sourceDatastorePath = null;
    }

    public String getVirtualMachineUUID() {
      return this.virtualMachineUUID;
    }

    public copyFromDatastoreToRepository_args setVirtualMachineUUID(String virtualMachineUUID) {
      this.virtualMachineUUID = virtualMachineUUID;
      return this;
    }

    public void unsetVirtualMachineUUID() {
      this.virtualMachineUUID = null;
    }

    /** Returns true if field virtualMachineUUID is set (has been asigned a value) and false otherwise */
    public boolean isSetVirtualMachineUUID() {
      return this.virtualMachineUUID != null;
    }

    public void setVirtualMachineUUIDIsSet(boolean value) {
      if (!value) {
        this.virtualMachineUUID = null;
      }
    }

    public String getSnapshot() {
      return this.snapshot;
    }

    public copyFromDatastoreToRepository_args setSnapshot(String snapshot) {
      this.snapshot = snapshot;
      return this;
    }

    public void unsetSnapshot() {
      this.snapshot = null;
    }

    /** Returns true if field snapshot is set (has been asigned a value) and false otherwise */
    public boolean isSetSnapshot() {
      return this.snapshot != null;
    }

    public void setSnapshotIsSet(boolean value) {
      if (!value) {
        this.snapshot = null;
      }
    }

    public String getDestinationRepositoryPath() {
      return this.destinationRepositoryPath;
    }

    public copyFromDatastoreToRepository_args setDestinationRepositoryPath(String destinationRepositoryPath) {
      this.destinationRepositoryPath = destinationRepositoryPath;
      return this;
    }

    public void unsetDestinationRepositoryPath() {
      this.destinationRepositoryPath = null;
    }

    /** Returns true if field destinationRepositoryPath is set (has been asigned a value) and false otherwise */
    public boolean isSetDestinationRepositoryPath() {
      return this.destinationRepositoryPath != null;
    }

    public void setDestinationRepositoryPathIsSet(boolean value) {
      if (!value) {
        this.destinationRepositoryPath = null;
      }
    }

    public String getSourceDatastorePath() {
      return this.sourceDatastorePath;
    }

    public copyFromDatastoreToRepository_args setSourceDatastorePath(String sourceDatastorePath) {
      this.sourceDatastorePath = sourceDatastorePath;
      return this;
    }

    public void unsetSourceDatastorePath() {
      this.sourceDatastorePath = null;
    }

    /** Returns true if field sourceDatastorePath is set (has been asigned a value) and false otherwise */
    public boolean isSetSourceDatastorePath() {
      return this.sourceDatastorePath != null;
    }

    public void setSourceDatastorePathIsSet(boolean value) {
      if (!value) {
        this.sourceDatastorePath = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VIRTUAL_MACHINE_UUID:
        if (value == null) {
          unsetVirtualMachineUUID();
        } else {
          setVirtualMachineUUID((String)value);
        }
        break;

      case SNAPSHOT:
        if (value == null) {
          unsetSnapshot();
        } else {
          setSnapshot((String)value);
        }
        break;

      case DESTINATION_REPOSITORY_PATH:
        if (value == null) {
          unsetDestinationRepositoryPath();
        } else {
          setDestinationRepositoryPath((String)value);
        }
        break;

      case SOURCE_DATASTORE_PATH:
        if (value == null) {
          unsetSourceDatastorePath();
        } else {
          setSourceDatastorePath((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VIRTUAL_MACHINE_UUID:
        return getVirtualMachineUUID();

      case SNAPSHOT:
        return getSnapshot();

      case DESTINATION_REPOSITORY_PATH:
        return getDestinationRepositoryPath();

      case SOURCE_DATASTORE_PATH:
        return getSourceDatastorePath();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case VIRTUAL_MACHINE_UUID:
        return isSetVirtualMachineUUID();
      case SNAPSHOT:
        return isSetSnapshot();
      case DESTINATION_REPOSITORY_PATH:
        return isSetDestinationRepositoryPath();
      case SOURCE_DATASTORE_PATH:
        return isSetSourceDatastorePath();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof copyFromDatastoreToRepository_args)
        return this.equals((copyFromDatastoreToRepository_args)that);
      return false;
    }

    public boolean equals(copyFromDatastoreToRepository_args that) {
      if (that == null)
        return false;

      boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
      boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
      if (this_present_virtualMachineUUID || that_present_virtualMachineUUID) {
        if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
          return false;
        if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
          return false;
      }

      boolean this_present_snapshot = true && this.isSetSnapshot();
      boolean that_present_snapshot = true && that.isSetSnapshot();
      if (this_present_snapshot || that_present_snapshot) {
        if (!(this_present_snapshot && that_present_snapshot))
          return false;
        if (!this.snapshot.equals(that.snapshot))
          return false;
      }

      boolean this_present_destinationRepositoryPath = true && this.isSetDestinationRepositoryPath();
      boolean that_present_destinationRepositoryPath = true && that.isSetDestinationRepositoryPath();
      if (this_present_destinationRepositoryPath || that_present_destinationRepositoryPath) {
        if (!(this_present_destinationRepositoryPath && that_present_destinationRepositoryPath))
          return false;
        if (!this.destinationRepositoryPath.equals(that.destinationRepositoryPath))
          return false;
      }

      boolean this_present_sourceDatastorePath = true && this.isSetSourceDatastorePath();
      boolean that_present_sourceDatastorePath = true && that.isSetSourceDatastorePath();
      if (this_present_sourceDatastorePath || that_present_sourceDatastorePath) {
        if (!(this_present_sourceDatastorePath && that_present_sourceDatastorePath))
          return false;
        if (!this.sourceDatastorePath.equals(that.sourceDatastorePath))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(copyFromDatastoreToRepository_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      copyFromDatastoreToRepository_args typedOther = (copyFromDatastoreToRepository_args)other;

      lastComparison = Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(typedOther.isSetVirtualMachineUUID());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVirtualMachineUUID()) {
        lastComparison = TBaseHelper.compareTo(this.virtualMachineUUID, typedOther.virtualMachineUUID);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSnapshot()).compareTo(typedOther.isSetSnapshot());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSnapshot()) {
        lastComparison = TBaseHelper.compareTo(this.snapshot, typedOther.snapshot);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetDestinationRepositoryPath()).compareTo(typedOther.isSetDestinationRepositoryPath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetDestinationRepositoryPath()) {
        lastComparison = TBaseHelper.compareTo(this.destinationRepositoryPath, typedOther.destinationRepositoryPath);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSourceDatastorePath()).compareTo(typedOther.isSetSourceDatastorePath());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSourceDatastorePath()) {
        lastComparison = TBaseHelper.compareTo(this.sourceDatastorePath, typedOther.sourceDatastorePath);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VIRTUAL_MACHINE_UUID
            if (field.type == TType.STRING) {
              this.virtualMachineUUID = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SNAPSHOT
            if (field.type == TType.STRING) {
              this.snapshot = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // DESTINATION_REPOSITORY_PATH
            if (field.type == TType.STRING) {
              this.destinationRepositoryPath = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // SOURCE_DATASTORE_PATH
            if (field.type == TType.STRING) {
              this.sourceDatastorePath = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.virtualMachineUUID != null) {
        oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
        oprot.writeString(this.virtualMachineUUID);
        oprot.writeFieldEnd();
      }
      if (this.snapshot != null) {
        oprot.writeFieldBegin(SNAPSHOT_FIELD_DESC);
        oprot.writeString(this.snapshot);
        oprot.writeFieldEnd();
      }
      if (this.destinationRepositoryPath != null) {
        oprot.writeFieldBegin(DESTINATION_REPOSITORY_PATH_FIELD_DESC);
        oprot.writeString(this.destinationRepositoryPath);
        oprot.writeFieldEnd();
      }
      if (this.sourceDatastorePath != null) {
        oprot.writeFieldBegin(SOURCE_DATASTORE_PATH_FIELD_DESC);
        oprot.writeString(this.sourceDatastorePath);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("copyFromDatastoreToRepository_args(");
      boolean first = true;

      sb.append("virtualMachineUUID:");
      if (this.virtualMachineUUID == null) {
        sb.append("null");
      } else {
        sb.append(this.virtualMachineUUID);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("snapshot:");
      if (this.snapshot == null) {
        sb.append("null");
      } else {
        sb.append(this.snapshot);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("destinationRepositoryPath:");
      if (this.destinationRepositoryPath == null) {
        sb.append("null");
      } else {
        sb.append(this.destinationRepositoryPath);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("sourceDatastorePath:");
      if (this.sourceDatastorePath == null) {
        sb.append("null");
      } else {
        sb.append(this.sourceDatastorePath);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class copyFromDatastoreToRepository_result implements TBase<copyFromDatastoreToRepository_result, copyFromDatastoreToRepository_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("copyFromDatastoreToRepository_result");

    private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short)1);

    public RimpException re;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RE((short)1, "re");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // RE
            return RE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.RE, new FieldMetaData("re", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(copyFromDatastoreToRepository_result.class, metaDataMap);
    }

    public copyFromDatastoreToRepository_result() {
    }

    public copyFromDatastoreToRepository_result(
      RimpException re)
    {
      this();
      this.re = re;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public copyFromDatastoreToRepository_result(copyFromDatastoreToRepository_result other) {
      if (other.isSetRe()) {
        this.re = new RimpException(other.re);
      }
    }

    public copyFromDatastoreToRepository_result deepCopy() {
      return new copyFromDatastoreToRepository_result(this);
    }

    @Override
    public void clear() {
      this.re = null;
    }

    public RimpException getRe() {
      return this.re;
    }

    public copyFromDatastoreToRepository_result setRe(RimpException re) {
      this.re = re;
      return this;
    }

    public void unsetRe() {
      this.re = null;
    }

    /** Returns true if field re is set (has been asigned a value) and false otherwise */
    public boolean isSetRe() {
      return this.re != null;
    }

    public void setReIsSet(boolean value) {
      if (!value) {
        this.re = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RE:
        if (value == null) {
          unsetRe();
        } else {
          setRe((RimpException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RE:
        return getRe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case RE:
        return isSetRe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof copyFromDatastoreToRepository_result)
        return this.equals((copyFromDatastoreToRepository_result)that);
      return false;
    }

    public boolean equals(copyFromDatastoreToRepository_result that) {
      if (that == null)
        return false;

      boolean this_present_re = true && this.isSetRe();
      boolean that_present_re = true && that.isSetRe();
      if (this_present_re || that_present_re) {
        if (!(this_present_re && that_present_re))
          return false;
        if (!this.re.equals(that.re))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(copyFromDatastoreToRepository_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      copyFromDatastoreToRepository_result typedOther = (copyFromDatastoreToRepository_result)other;

      lastComparison = Boolean.valueOf(isSetRe()).compareTo(typedOther.isSetRe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRe()) {
        lastComparison = TBaseHelper.compareTo(this.re, typedOther.re);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // RE
            if (field.type == TType.STRUCT) {
              this.re = new RimpException();
              this.re.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetRe()) {
        oprot.writeFieldBegin(RE_FIELD_DESC);
        this.re.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("copyFromDatastoreToRepository_result(");
      boolean first = true;

      sb.append("re:");
      if (this.re == null) {
        sb.append("null");
      } else {
        sb.append(this.re);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createVLAN_args implements TBase<createVLAN_args, createVLAN_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createVLAN_args");

    private static final TField VLAN_TAG_FIELD_DESC = new TField("vlanTag", TType.I32, (short)1);
    private static final TField VLAN_INTERFACE_FIELD_DESC = new TField("vlanInterface", TType.STRING, (short)2);
    private static final TField BRIDGE_INTERFACE_FIELD_DESC = new TField("bridgeInterface", TType.STRING, (short)3);

    public int vlanTag;
    public String vlanInterface;
    public String bridgeInterface;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VLAN_TAG((short)1, "vlanTag"),
      VLAN_INTERFACE((short)2, "vlanInterface"),
      BRIDGE_INTERFACE((short)3, "bridgeInterface");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // VLAN_TAG
            return VLAN_TAG;
          case 2: // VLAN_INTERFACE
            return VLAN_INTERFACE;
          case 3: // BRIDGE_INTERFACE
            return BRIDGE_INTERFACE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __VLANTAG_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.VLAN_TAG, new FieldMetaData("vlanTag", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.VLAN_INTERFACE, new FieldMetaData("vlanInterface", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.BRIDGE_INTERFACE, new FieldMetaData("bridgeInterface", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(createVLAN_args.class, metaDataMap);
    }

    public createVLAN_args() {
    }

    public createVLAN_args(
      int vlanTag,
      String vlanInterface,
      String bridgeInterface)
    {
      this();
      this.vlanTag = vlanTag;
      setVlanTagIsSet(true);
      this.vlanInterface = vlanInterface;
      this.bridgeInterface = bridgeInterface;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createVLAN_args(createVLAN_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.vlanTag = other.vlanTag;
      if (other.isSetVlanInterface()) {
        this.vlanInterface = other.vlanInterface;
      }
      if (other.isSetBridgeInterface()) {
        this.bridgeInterface = other.bridgeInterface;
      }
    }

    public createVLAN_args deepCopy() {
      return new createVLAN_args(this);
    }

    @Override
    public void clear() {
      setVlanTagIsSet(false);
      this.vlanTag = 0;
      this.vlanInterface = null;
      this.bridgeInterface = null;
    }

    public int getVlanTag() {
      return this.vlanTag;
    }

    public createVLAN_args setVlanTag(int vlanTag) {
      this.vlanTag = vlanTag;
      setVlanTagIsSet(true);
      return this;
    }

    public void unsetVlanTag() {
      __isset_bit_vector.clear(__VLANTAG_ISSET_ID);
    }

    /** Returns true if field vlanTag is set (has been asigned a value) and false otherwise */
    public boolean isSetVlanTag() {
      return __isset_bit_vector.get(__VLANTAG_ISSET_ID);
    }

    public void setVlanTagIsSet(boolean value) {
      __isset_bit_vector.set(__VLANTAG_ISSET_ID, value);
    }

    public String getVlanInterface() {
      return this.vlanInterface;
    }

    public createVLAN_args setVlanInterface(String vlanInterface) {
      this.vlanInterface = vlanInterface;
      return this;
    }

    public void unsetVlanInterface() {
      this.vlanInterface = null;
    }

    /** Returns true if field vlanInterface is set (has been asigned a value) and false otherwise */
    public boolean isSetVlanInterface() {
      return this.vlanInterface != null;
    }

    public void setVlanInterfaceIsSet(boolean value) {
      if (!value) {
        this.vlanInterface = null;
      }
    }

    public String getBridgeInterface() {
      return this.bridgeInterface;
    }

    public createVLAN_args setBridgeInterface(String bridgeInterface) {
      this.bridgeInterface = bridgeInterface;
      return this;
    }

    public void unsetBridgeInterface() {
      this.bridgeInterface = null;
    }

    /** Returns true if field bridgeInterface is set (has been asigned a value) and false otherwise */
    public boolean isSetBridgeInterface() {
      return this.bridgeInterface != null;
    }

    public void setBridgeInterfaceIsSet(boolean value) {
      if (!value) {
        this.bridgeInterface = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VLAN_TAG:
        if (value == null) {
          unsetVlanTag();
        } else {
          setVlanTag((Integer)value);
        }
        break;

      case VLAN_INTERFACE:
        if (value == null) {
          unsetVlanInterface();
        } else {
          setVlanInterface((String)value);
        }
        break;

      case BRIDGE_INTERFACE:
        if (value == null) {
          unsetBridgeInterface();
        } else {
          setBridgeInterface((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VLAN_TAG:
        return new Integer(getVlanTag());

      case VLAN_INTERFACE:
        return getVlanInterface();

      case BRIDGE_INTERFACE:
        return getBridgeInterface();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case VLAN_TAG:
        return isSetVlanTag();
      case VLAN_INTERFACE:
        return isSetVlanInterface();
      case BRIDGE_INTERFACE:
        return isSetBridgeInterface();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createVLAN_args)
        return this.equals((createVLAN_args)that);
      return false;
    }

    public boolean equals(createVLAN_args that) {
      if (that == null)
        return false;

      boolean this_present_vlanTag = true;
      boolean that_present_vlanTag = true;
      if (this_present_vlanTag || that_present_vlanTag) {
        if (!(this_present_vlanTag && that_present_vlanTag))
          return false;
        if (this.vlanTag != that.vlanTag)
          return false;
      }

      boolean this_present_vlanInterface = true && this.isSetVlanInterface();
      boolean that_present_vlanInterface = true && that.isSetVlanInterface();
      if (this_present_vlanInterface || that_present_vlanInterface) {
        if (!(this_present_vlanInterface && that_present_vlanInterface))
          return false;
        if (!this.vlanInterface.equals(that.vlanInterface))
          return false;
      }

      boolean this_present_bridgeInterface = true && this.isSetBridgeInterface();
      boolean that_present_bridgeInterface = true && that.isSetBridgeInterface();
      if (this_present_bridgeInterface || that_present_bridgeInterface) {
        if (!(this_present_bridgeInterface && that_present_bridgeInterface))
          return false;
        if (!this.bridgeInterface.equals(that.bridgeInterface))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(createVLAN_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      createVLAN_args typedOther = (createVLAN_args)other;

      lastComparison = Boolean.valueOf(isSetVlanTag()).compareTo(typedOther.isSetVlanTag());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVlanTag()) {
        lastComparison = TBaseHelper.compareTo(this.vlanTag, typedOther.vlanTag);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetVlanInterface()).compareTo(typedOther.isSetVlanInterface());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVlanInterface()) {
        lastComparison = TBaseHelper.compareTo(this.vlanInterface, typedOther.vlanInterface);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetBridgeInterface()).compareTo(typedOther.isSetBridgeInterface());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetBridgeInterface()) {
        lastComparison = TBaseHelper.compareTo(this.bridgeInterface, typedOther.bridgeInterface);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VLAN_TAG
            if (field.type == TType.I32) {
              this.vlanTag = iprot.readI32();
              setVlanTagIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // VLAN_INTERFACE
            if (field.type == TType.STRING) {
              this.vlanInterface = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // BRIDGE_INTERFACE
            if (field.type == TType.STRING) {
              this.bridgeInterface = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(VLAN_TAG_FIELD_DESC);
      oprot.writeI32(this.vlanTag);
      oprot.writeFieldEnd();
      if (this.vlanInterface != null) {
        oprot.writeFieldBegin(VLAN_INTERFACE_FIELD_DESC);
        oprot.writeString(this.vlanInterface);
        oprot.writeFieldEnd();
      }
      if (this.bridgeInterface != null) {
        oprot.writeFieldBegin(BRIDGE_INTERFACE_FIELD_DESC);
        oprot.writeString(this.bridgeInterface);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createVLAN_args(");
      boolean first = true;

      sb.append("vlanTag:");
      sb.append(this.vlanTag);
      first = false;
      if (!first) sb.append(", ");
      sb.append("vlanInterface:");
      if (this.vlanInterface == null) {
        sb.append("null");
      } else {
        sb.append(this.vlanInterface);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("bridgeInterface:");
      if (this.bridgeInterface == null) {
        sb.append("null");
      } else {
        sb.append(this.bridgeInterface);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class createVLAN_result implements TBase<createVLAN_result, createVLAN_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("createVLAN_result");

    private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short)1);

    public VLanException ve;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VE((short)1, "ve");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // VE
            return VE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.VE, new FieldMetaData("ve", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(createVLAN_result.class, metaDataMap);
    }

    public createVLAN_result() {
    }

    public createVLAN_result(
      VLanException ve)
    {
      this();
      this.ve = ve;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public createVLAN_result(createVLAN_result other) {
      if (other.isSetVe()) {
        this.ve = new VLanException(other.ve);
      }
    }

    public createVLAN_result deepCopy() {
      return new createVLAN_result(this);
    }

    @Override
    public void clear() {
      this.ve = null;
    }

    public VLanException getVe() {
      return this.ve;
    }

    public createVLAN_result setVe(VLanException ve) {
      this.ve = ve;
      return this;
    }

    public void unsetVe() {
      this.ve = null;
    }

    /** Returns true if field ve is set (has been asigned a value) and false otherwise */
    public boolean isSetVe() {
      return this.ve != null;
    }

    public void setVeIsSet(boolean value) {
      if (!value) {
        this.ve = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VE:
        if (value == null) {
          unsetVe();
        } else {
          setVe((VLanException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VE:
        return getVe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case VE:
        return isSetVe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof createVLAN_result)
        return this.equals((createVLAN_result)that);
      return false;
    }

    public boolean equals(createVLAN_result that) {
      if (that == null)
        return false;

      boolean this_present_ve = true && this.isSetVe();
      boolean that_present_ve = true && that.isSetVe();
      if (this_present_ve || that_present_ve) {
        if (!(this_present_ve && that_present_ve))
          return false;
        if (!this.ve.equals(that.ve))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(createVLAN_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      createVLAN_result typedOther = (createVLAN_result)other;

      lastComparison = Boolean.valueOf(isSetVe()).compareTo(typedOther.isSetVe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVe()) {
        lastComparison = TBaseHelper.compareTo(this.ve, typedOther.ve);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VE
            if (field.type == TType.STRUCT) {
              this.ve = new VLanException();
              this.ve.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetVe()) {
        oprot.writeFieldBegin(VE_FIELD_DESC);
        this.ve.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("createVLAN_result(");
      boolean first = true;

      sb.append("ve:");
      if (this.ve == null) {
        sb.append("null");
      } else {
        sb.append(this.ve);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteVLAN_args implements TBase<deleteVLAN_args, deleteVLAN_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteVLAN_args");

    private static final TField VLAN_TAG_FIELD_DESC = new TField("vlanTag", TType.I32, (short)1);
    private static final TField VLAN_INTERFACE_FIELD_DESC = new TField("vlanInterface", TType.STRING, (short)2);
    private static final TField BRIDGE_INTERFACE_FIELD_DESC = new TField("bridgeInterface", TType.STRING, (short)3);

    public int vlanTag;
    public String vlanInterface;
    public String bridgeInterface;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VLAN_TAG((short)1, "vlanTag"),
      VLAN_INTERFACE((short)2, "vlanInterface"),
      BRIDGE_INTERFACE((short)3, "bridgeInterface");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // VLAN_TAG
            return VLAN_TAG;
          case 2: // VLAN_INTERFACE
            return VLAN_INTERFACE;
          case 3: // BRIDGE_INTERFACE
            return BRIDGE_INTERFACE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __VLANTAG_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.VLAN_TAG, new FieldMetaData("vlanTag", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.VLAN_INTERFACE, new FieldMetaData("vlanInterface", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.BRIDGE_INTERFACE, new FieldMetaData("bridgeInterface", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteVLAN_args.class, metaDataMap);
    }

    public deleteVLAN_args() {
    }

    public deleteVLAN_args(
      int vlanTag,
      String vlanInterface,
      String bridgeInterface)
    {
      this();
      this.vlanTag = vlanTag;
      setVlanTagIsSet(true);
      this.vlanInterface = vlanInterface;
      this.bridgeInterface = bridgeInterface;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteVLAN_args(deleteVLAN_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.vlanTag = other.vlanTag;
      if (other.isSetVlanInterface()) {
        this.vlanInterface = other.vlanInterface;
      }
      if (other.isSetBridgeInterface()) {
        this.bridgeInterface = other.bridgeInterface;
      }
    }

    public deleteVLAN_args deepCopy() {
      return new deleteVLAN_args(this);
    }

    @Override
    public void clear() {
      setVlanTagIsSet(false);
      this.vlanTag = 0;
      this.vlanInterface = null;
      this.bridgeInterface = null;
    }

    public int getVlanTag() {
      return this.vlanTag;
    }

    public deleteVLAN_args setVlanTag(int vlanTag) {
      this.vlanTag = vlanTag;
      setVlanTagIsSet(true);
      return this;
    }

    public void unsetVlanTag() {
      __isset_bit_vector.clear(__VLANTAG_ISSET_ID);
    }

    /** Returns true if field vlanTag is set (has been asigned a value) and false otherwise */
    public boolean isSetVlanTag() {
      return __isset_bit_vector.get(__VLANTAG_ISSET_ID);
    }

    public void setVlanTagIsSet(boolean value) {
      __isset_bit_vector.set(__VLANTAG_ISSET_ID, value);
    }

    public String getVlanInterface() {
      return this.vlanInterface;
    }

    public deleteVLAN_args setVlanInterface(String vlanInterface) {
      this.vlanInterface = vlanInterface;
      return this;
    }

    public void unsetVlanInterface() {
      this.vlanInterface = null;
    }

    /** Returns true if field vlanInterface is set (has been asigned a value) and false otherwise */
    public boolean isSetVlanInterface() {
      return this.vlanInterface != null;
    }

    public void setVlanInterfaceIsSet(boolean value) {
      if (!value) {
        this.vlanInterface = null;
      }
    }

    public String getBridgeInterface() {
      return this.bridgeInterface;
    }

    public deleteVLAN_args setBridgeInterface(String bridgeInterface) {
      this.bridgeInterface = bridgeInterface;
      return this;
    }

    public void unsetBridgeInterface() {
      this.bridgeInterface = null;
    }

    /** Returns true if field bridgeInterface is set (has been asigned a value) and false otherwise */
    public boolean isSetBridgeInterface() {
      return this.bridgeInterface != null;
    }

    public void setBridgeInterfaceIsSet(boolean value) {
      if (!value) {
        this.bridgeInterface = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VLAN_TAG:
        if (value == null) {
          unsetVlanTag();
        } else {
          setVlanTag((Integer)value);
        }
        break;

      case VLAN_INTERFACE:
        if (value == null) {
          unsetVlanInterface();
        } else {
          setVlanInterface((String)value);
        }
        break;

      case BRIDGE_INTERFACE:
        if (value == null) {
          unsetBridgeInterface();
        } else {
          setBridgeInterface((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VLAN_TAG:
        return new Integer(getVlanTag());

      case VLAN_INTERFACE:
        return getVlanInterface();

      case BRIDGE_INTERFACE:
        return getBridgeInterface();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case VLAN_TAG:
        return isSetVlanTag();
      case VLAN_INTERFACE:
        return isSetVlanInterface();
      case BRIDGE_INTERFACE:
        return isSetBridgeInterface();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteVLAN_args)
        return this.equals((deleteVLAN_args)that);
      return false;
    }

    public boolean equals(deleteVLAN_args that) {
      if (that == null)
        return false;

      boolean this_present_vlanTag = true;
      boolean that_present_vlanTag = true;
      if (this_present_vlanTag || that_present_vlanTag) {
        if (!(this_present_vlanTag && that_present_vlanTag))
          return false;
        if (this.vlanTag != that.vlanTag)
          return false;
      }

      boolean this_present_vlanInterface = true && this.isSetVlanInterface();
      boolean that_present_vlanInterface = true && that.isSetVlanInterface();
      if (this_present_vlanInterface || that_present_vlanInterface) {
        if (!(this_present_vlanInterface && that_present_vlanInterface))
          return false;
        if (!this.vlanInterface.equals(that.vlanInterface))
          return false;
      }

      boolean this_present_bridgeInterface = true && this.isSetBridgeInterface();
      boolean that_present_bridgeInterface = true && that.isSetBridgeInterface();
      if (this_present_bridgeInterface || that_present_bridgeInterface) {
        if (!(this_present_bridgeInterface && that_present_bridgeInterface))
          return false;
        if (!this.bridgeInterface.equals(that.bridgeInterface))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteVLAN_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteVLAN_args typedOther = (deleteVLAN_args)other;

      lastComparison = Boolean.valueOf(isSetVlanTag()).compareTo(typedOther.isSetVlanTag());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVlanTag()) {
        lastComparison = TBaseHelper.compareTo(this.vlanTag, typedOther.vlanTag);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetVlanInterface()).compareTo(typedOther.isSetVlanInterface());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVlanInterface()) {
        lastComparison = TBaseHelper.compareTo(this.vlanInterface, typedOther.vlanInterface);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetBridgeInterface()).compareTo(typedOther.isSetBridgeInterface());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetBridgeInterface()) {
        lastComparison = TBaseHelper.compareTo(this.bridgeInterface, typedOther.bridgeInterface);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VLAN_TAG
            if (field.type == TType.I32) {
              this.vlanTag = iprot.readI32();
              setVlanTagIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // VLAN_INTERFACE
            if (field.type == TType.STRING) {
              this.vlanInterface = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // BRIDGE_INTERFACE
            if (field.type == TType.STRING) {
              this.bridgeInterface = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(VLAN_TAG_FIELD_DESC);
      oprot.writeI32(this.vlanTag);
      oprot.writeFieldEnd();
      if (this.vlanInterface != null) {
        oprot.writeFieldBegin(VLAN_INTERFACE_FIELD_DESC);
        oprot.writeString(this.vlanInterface);
        oprot.writeFieldEnd();
      }
      if (this.bridgeInterface != null) {
        oprot.writeFieldBegin(BRIDGE_INTERFACE_FIELD_DESC);
        oprot.writeString(this.bridgeInterface);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteVLAN_args(");
      boolean first = true;

      sb.append("vlanTag:");
      sb.append(this.vlanTag);
      first = false;
      if (!first) sb.append(", ");
      sb.append("vlanInterface:");
      if (this.vlanInterface == null) {
        sb.append("null");
      } else {
        sb.append(this.vlanInterface);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("bridgeInterface:");
      if (this.bridgeInterface == null) {
        sb.append("null");
      } else {
        sb.append(this.bridgeInterface);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class deleteVLAN_result implements TBase<deleteVLAN_result, deleteVLAN_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("deleteVLAN_result");

    private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short)1);

    public VLanException ve;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VE((short)1, "ve");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // VE
            return VE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.VE, new FieldMetaData("ve", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(deleteVLAN_result.class, metaDataMap);
    }

    public deleteVLAN_result() {
    }

    public deleteVLAN_result(
      VLanException ve)
    {
      this();
      this.ve = ve;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public deleteVLAN_result(deleteVLAN_result other) {
      if (other.isSetVe()) {
        this.ve = new VLanException(other.ve);
      }
    }

    public deleteVLAN_result deepCopy() {
      return new deleteVLAN_result(this);
    }

    @Override
    public void clear() {
      this.ve = null;
    }

    public VLanException getVe() {
      return this.ve;
    }

    public deleteVLAN_result setVe(VLanException ve) {
      this.ve = ve;
      return this;
    }

    public void unsetVe() {
      this.ve = null;
    }

    /** Returns true if field ve is set (has been asigned a value) and false otherwise */
    public boolean isSetVe() {
      return this.ve != null;
    }

    public void setVeIsSet(boolean value) {
      if (!value) {
        this.ve = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VE:
        if (value == null) {
          unsetVe();
        } else {
          setVe((VLanException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VE:
        return getVe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case VE:
        return isSetVe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof deleteVLAN_result)
        return this.equals((deleteVLAN_result)that);
      return false;
    }

    public boolean equals(deleteVLAN_result that) {
      if (that == null)
        return false;

      boolean this_present_ve = true && this.isSetVe();
      boolean that_present_ve = true && that.isSetVe();
      if (this_present_ve || that_present_ve) {
        if (!(this_present_ve && that_present_ve))
          return false;
        if (!this.ve.equals(that.ve))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(deleteVLAN_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      deleteVLAN_result typedOther = (deleteVLAN_result)other;

      lastComparison = Boolean.valueOf(isSetVe()).compareTo(typedOther.isSetVe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVe()) {
        lastComparison = TBaseHelper.compareTo(this.ve, typedOther.ve);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VE
            if (field.type == TType.STRUCT) {
              this.ve = new VLanException();
              this.ve.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetVe()) {
        oprot.writeFieldBegin(VE_FIELD_DESC);
        this.ve.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("deleteVLAN_result(");
      boolean first = true;

      sb.append("ve:");
      if (this.ve == null) {
        sb.append("null");
      } else {
        sb.append(this.ve);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkVLANConfiguration_args implements TBase<checkVLANConfiguration_args, checkVLANConfiguration_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkVLANConfiguration_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkVLANConfiguration_args.class, metaDataMap);
    }

    public checkVLANConfiguration_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkVLANConfiguration_args(checkVLANConfiguration_args other) {
    }

    public checkVLANConfiguration_args deepCopy() {
      return new checkVLANConfiguration_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkVLANConfiguration_args)
        return this.equals((checkVLANConfiguration_args)that);
      return false;
    }

    public boolean equals(checkVLANConfiguration_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkVLANConfiguration_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkVLANConfiguration_args typedOther = (checkVLANConfiguration_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkVLANConfiguration_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class checkVLANConfiguration_result implements TBase<checkVLANConfiguration_result, checkVLANConfiguration_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("checkVLANConfiguration_result");

    private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short)1);

    public VLanException ve;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      VE((short)1, "ve");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // VE
            return VE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.VE, new FieldMetaData("ve", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(checkVLANConfiguration_result.class, metaDataMap);
    }

    public checkVLANConfiguration_result() {
    }

    public checkVLANConfiguration_result(
      VLanException ve)
    {
      this();
      this.ve = ve;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public checkVLANConfiguration_result(checkVLANConfiguration_result other) {
      if (other.isSetVe()) {
        this.ve = new VLanException(other.ve);
      }
    }

    public checkVLANConfiguration_result deepCopy() {
      return new checkVLANConfiguration_result(this);
    }

    @Override
    public void clear() {
      this.ve = null;
    }

    public VLanException getVe() {
      return this.ve;
    }

    public checkVLANConfiguration_result setVe(VLanException ve) {
      this.ve = ve;
      return this;
    }

    public void unsetVe() {
      this.ve = null;
    }

    /** Returns true if field ve is set (has been asigned a value) and false otherwise */
    public boolean isSetVe() {
      return this.ve != null;
    }

    public void setVeIsSet(boolean value) {
      if (!value) {
        this.ve = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case VE:
        if (value == null) {
          unsetVe();
        } else {
          setVe((VLanException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case VE:
        return getVe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case VE:
        return isSetVe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof checkVLANConfiguration_result)
        return this.equals((checkVLANConfiguration_result)that);
      return false;
    }

    public boolean equals(checkVLANConfiguration_result that) {
      if (that == null)
        return false;

      boolean this_present_ve = true && this.isSetVe();
      boolean that_present_ve = true && that.isSetVe();
      if (this_present_ve || that_present_ve) {
        if (!(this_present_ve && that_present_ve))
          return false;
        if (!this.ve.equals(that.ve))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(checkVLANConfiguration_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      checkVLANConfiguration_result typedOther = (checkVLANConfiguration_result)other;

      lastComparison = Boolean.valueOf(isSetVe()).compareTo(typedOther.isSetVe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetVe()) {
        lastComparison = TBaseHelper.compareTo(this.ve, typedOther.ve);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // VE
            if (field.type == TType.STRUCT) {
              this.ve = new VLanException();
              this.ve.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetVe()) {
        oprot.writeFieldBegin(VE_FIELD_DESC);
        this.ve.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("checkVLANConfiguration_result(");
      boolean first = true;

      sb.append("ve:");
      if (this.ve == null) {
        sb.append("null");
      } else {
        sb.append(this.ve);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getInitiatorIQN_args implements TBase<getInitiatorIQN_args, getInitiatorIQN_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getInitiatorIQN_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getInitiatorIQN_args.class, metaDataMap);
    }

    public getInitiatorIQN_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getInitiatorIQN_args(getInitiatorIQN_args other) {
    }

    public getInitiatorIQN_args deepCopy() {
      return new getInitiatorIQN_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getInitiatorIQN_args)
        return this.equals((getInitiatorIQN_args)that);
      return false;
    }

    public boolean equals(getInitiatorIQN_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getInitiatorIQN_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getInitiatorIQN_args typedOther = (getInitiatorIQN_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getInitiatorIQN_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getInitiatorIQN_result implements TBase<getInitiatorIQN_result, getInitiatorIQN_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getInitiatorIQN_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getInitiatorIQN_result.class, metaDataMap);
    }

    public getInitiatorIQN_result() {
    }

    public getInitiatorIQN_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getInitiatorIQN_result(getInitiatorIQN_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public getInitiatorIQN_result deepCopy() {
      return new getInitiatorIQN_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
    }

    public String getSuccess() {
      return this.success;
    }

    public getInitiatorIQN_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getInitiatorIQN_result)
        return this.equals((getInitiatorIQN_result)that);
      return false;
    }

    public boolean equals(getInitiatorIQN_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getInitiatorIQN_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getInitiatorIQN_result typedOther = (getInitiatorIQN_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getInitiatorIQN_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
